import BigNumber from 'bignumber.js';
import { EventEmitter } from 'events';

type Branding<BrandT> = {
    _type: BrandT;
};
type Brand<T, BrandT> = T & Branding<BrandT>;

type NumericAmount = string | number | BigNumber;
type SqrtPrice = Brand<BigNumber, 'SqrtPrice'>;
type SqrtPriceIn = Brand<NumericAmount, 'SqrtPriceIn'> | SqrtPrice;
type Price = Brand<BigNumber, 'Price'>;
type PriceIn = Brand<NumericAmount, 'PriceIn'> | Price;

interface GalaChainTokenClassKey {
    collection: string;
    category: string;
    type: string;
    additionalKey: string;
}

/**
 * Result from getting a price quote for a token swap.
 * Contains pricing information and impact analysis for the proposed trade.
 */
interface GetQuoteResult {
    /** Raw amount of token0 that would be involved in the swap (ordered by token address) */
    amount0: BigNumber;
    /** Raw amount of token1 that would be involved in the swap (ordered by token address) */
    amount1: BigNumber;
    /** Current square root price of the pool before the trade */
    currentPoolSqrtPrice: SqrtPrice;
    /** New square root price of the pool after the trade would execute */
    newPoolSqrtPrice: SqrtPrice;
    /** Amount of the input token (the token being sold) */
    inTokenAmount: BigNumber;
    /** Amount of the output token (the token being bought) */
    outTokenAmount: BigNumber;
    /** Current price of the pool (how many output tokens per input token) */
    currentPrice: Price;
    /** New price of the pool after the trade (how many output tokens per input token) */
    newPrice: Price;
    /** Price impact of the trade as a percentage (e.g., 0.05 for 0.05% impact) */
    priceImpact: BigNumber;
    /** Fee tier of the pool used for this quote (e.g., 500 for 0.05%, 3000 for 0.3%) */
    feeTier: number;
}
/**
 * Result from getting all liquidity positions for a user.
 * Contains summary information about each position owned by the wallet.
 */
interface GetUserPositionsResult {
    /** Unique hash identifier for the liquidity pool */
    poolHash: string;
    /** Unique identifier for this specific liquidity position */
    positionId: string;
    /** Token class key for the first token in the pair */
    token0ClassKey: GalaChainTokenClassKey;
    /** Token class key for the second token in the pair */
    token1ClassKey: GalaChainTokenClassKey;
    /** URL or path to the image/icon for token0 */
    token0Img: string;
    /** URL or path to the image/icon for token1 */
    token1Img: string;
    /** Symbol/ticker for token0 (e.g., "GALA") */
    token0Symbol: string;
    /** Symbol/ticker for token1 (e.g., "USDC") */
    token1Symbol: string;
    /** Fee tier of the pool (e.g., 500 for 0.05%, 3000 for 0.3%) */
    fee: number;
    /** Amount of liquidity provided in this position */
    liquidity: BigNumber;
    /** Lower tick boundary of the position's price range */
    tickLower: number;
    /** Upper tick boundary of the position's price range */
    tickUpper: number;
    /** Timestamp when the position was created */
    createdAt: string;
}
/**
 * Result from getting detailed information about a specific liquidity position.
 * Contains comprehensive data about position state, fees, and token information.
 */
interface GetPositionResult {
    /** Fee tier of the pool (e.g., 500 for 0.05%, 3000 for 0.3%) */
    fee: number;
    /** Fee growth inside the position's tick range for token0 since position creation */
    feeGrowthInside0Last: BigNumber;
    /** Fee growth inside the position's tick range for token1 since position creation */
    feeGrowthInside1Last: BigNumber;
    /** Amount of liquidity provided in this position */
    liquidity: BigNumber;
    /** Unique hash identifier for the liquidity pool */
    poolHash: string;
    /** Unique identifier for this specific liquidity position */
    positionId: string;
    /** Lower tick boundary of the position's price range */
    tickLower: number;
    /** Upper tick boundary of the position's price range */
    tickUpper: number;
    /** Token class key for the first token in the pair (ordered by token address) */
    token0ClassKey: GalaChainTokenClassKey;
    /** Token class key for the second token in the pair (ordered by token address) */
    token1ClassKey: GalaChainTokenClassKey;
    /** Amount of token0 fees accumulated and owed to the position owner */
    tokensOwed0: BigNumber;
    /** Amount of token1 fees accumulated and owed to the position owner */
    tokensOwed1: BigNumber;
}
/**
 * Represents a single asset (token) in a user's wallet.
 * Contains token metadata and balance information.
 */
interface UserAsset {
    /** URL to the token's icon/image */
    image: string;
    /** Human-readable name of the token */
    name: string;
    /** Number of decimal places this token uses */
    decimals: number;
    /** Whether this token has been verified/approved */
    verify: boolean;
    /** Trading symbol for the token */
    symbol: string;
    /** User's balance of this token as a decimal string */
    quantity: string;
}
/**
 * Result from getting a user's asset balances.
 * Contains paginated list of tokens and their balances.
 */
interface GetUserAssetsResult {
    /** Array of tokens owned by the user */
    tokens: UserAsset[];
    /** Total number of different tokens the user owns */
    count: number;
}

type FetchReturnValue = Awaited<ReturnType<typeof fetch>>;
interface HTTPResponse {
    ok: FetchReturnValue['ok'];
    status: FetchReturnValue['status'];
    json: FetchReturnValue['json'];
    text: FetchReturnValue['text'];
}
type HttpRequestor = (uri: string, options?: Parameters<typeof fetch>[1]) => Promise<HTTPResponse>;

declare class HttpClient {
    private readonly httpRequestor;
    constructor(httpRequestor?: HttpRequestor);
    private sendRequest;
    sendPostRequest<TReturnType>(baseUrl: string, basePath: string, endpoint: string, body: unknown): Promise<TReturnType>;
    sendGetRequest<TReturnType>(baseUrl: string, basePath: string, endpoint: string, params?: Record<string, string>): Promise<TReturnType>;
}

/**
 * Service for handling user asset operations.
 * Provides functionality to retrieve user token balances and asset information.
 */
declare class Assets {
    private readonly dexBackendBaseUrl;
    private readonly httpClient;
    constructor(dexBackendBaseUrl: string, httpClient: HttpClient);
    /**
     * Gets all token assets owned by a user with their balances.
     * @param ownerAddress - The wallet address to get assets for.
     * @param page - Page number for pagination (default: 1).
     * @param limit - Maximum number of assets to return per page (default: 10).
     * @returns User assets including token information and balances.
     * @example
     * ```typescript
     * const assets = await assetsService.getUserAssets('eth|123...abc', 1, 20);
     * console.log(`User has ${assets.count} different tokens`);
     * assets.tokens.forEach(token => {
     *   console.log(`${token.symbol}: ${token.quantity}`);
     * });
     * ```
     */
    getUserAssets(ownerAddress: string, page?: number, limit?: number): Promise<GetUserAssetsResult>;
}

/**
 * @hideconstructor
 * Represents a pending blockchain transaction.
 *
 * Usage: Call `wait()` immediately after receiving the PendingTransaction
 * to ensure proper event handling:
 *```typescript
 * const pendingTx = await gSwap.swap(...);
 * const result = await pendingTx.wait(); // Call immediately - if you delay then the event may be missed
 *```
 */
declare class PendingTransaction {
    readonly transactionId: string;
    readonly message: string;
    readonly error: boolean;
    private readonly waitDelegate;
    constructor(transactionId: string, message: string, error: boolean, waitDelegate: () => Promise<{
        txId: string;
        transactionHash: string;
        Data: Record<string, unknown>;
    }>);
    /**
     * Waits for the transaction to be confirmed.
     * This should be called immediately after receiving the PendingTransaction
     * to ensure proper event handling. If you delay calling this method and the
     * transaction confirms before you call this method, an error will be thrown.
     *
     * @returns A promise that resolves when the transaction is confirmed.
     */
    wait(): Promise<{
        txId: string;
        transactionHash: string;
        Data: Record<string, unknown>;
    }>;
}

/**
 * A transaction signing interface. See {@link PrivateKeySigner} and {@link GalaWalletSigner} for implementations.
 */
interface GalaChainSigner {
    signObject: <TObjectType extends Record<string, unknown>>(methodName: string, object: TObjectType) => Promise<TObjectType & {
        signature: string;
    }>;
}
/**
 * A signing implementation that uses a private key string to sign requests.
 */
declare class PrivateKeySigner implements GalaChainSigner {
    private readonly keyBuffer;
    constructor(privateKey: string);
    signObject<TObjectType extends Record<string, unknown>>(_methodName: string, obj: TObjectType): Promise<TObjectType & {
        signature: string;
    }>;
}
/**
 * A signing implementation that uses Gala Wallet to sign requests.
 */
declare class GalaWalletSigner implements GalaChainSigner {
    readonly walletAddress: string;
    constructor(walletAddress: string);
    signObject<TObjectType extends Record<string, unknown>>(methodName: string, obj: TObjectType): Promise<TObjectType & {
        signature: string;
    }>;
    private static generateEIP712Types;
}

declare class Bundler {
    private readonly bundlerBaseUrl;
    private readonly bundlingAPIBasePath;
    private readonly transactionWaitTimeoutMs;
    private readonly signer;
    private readonly httpClient;
    constructor(bundlerBaseUrl: string, bundlingAPIBasePath: string, transactionWaitTimeoutMs: number, signer: GalaChainSigner | undefined, httpClient: HttpClient);
    signObject<TInputType extends Record<string, unknown>>(methodName: string, toSign: TInputType): Promise<TInputType & {
        signature: string;
    }>;
    sendBundlerRequest(method: string, body: Record<string, unknown>, stringsInstructions: string[]): Promise<PendingTransaction>;
    hasSigner(): boolean;
}

type BundlerResponse = {
    status: 'FAILED';
    transactionHash: string;
    data: {
        ErrorCode: number;
        ErrorKey: string;
        ErrorPayload: Record<string, unknown>;
        Message: string;
        transactionId: string;
    };
} | {
    status: 'PROCESSED';
    transactionHash: string;
    data: {
        Data: Record<string, unknown>;
        transactionId: string;
    };
};
interface BundlerRequest {
    data: string;
    message: string;
    error: boolean;
}
declare abstract class TradeEventEmitter extends EventEmitter {
    abstract connect(): Promise<void>;
    abstract disconnect(): void;
    abstract isConnected(): boolean;
}
declare class EventSocketClient extends TradeEventEmitter {
    private socket;
    private readonly bundlerUrl;
    constructor(bundlerUrl: string);
    connect(): Promise<void>;
    disconnect(): void;
    isConnected(): boolean;
}

/**
 * Service for handling real-time event streaming and socket connections.
 * Manages the global socket connection for transaction status updates.
 */
declare class Events {
    private globalSocketClient?;
    private globalWaitHelper;
    private connectionPromise?;
    static readonly instance: Events;
    static tradeEventEmitterConstructor: new (url: string) => TradeEventEmitter;
    /**
     * Establishes a global socket connection for real-time event streaming.
     * This connection is shared across all service instances.
     * @param bundlerBaseUrl - Optional bundler base URL. If not provided, uses default.
     * @returns The connected EventSocketClient.
     * @example
     * ```typescript
     * await eventsService.connectEventSocket();
     *
     * // Socket is now available for transaction updates
     * ```
     */
    connectEventSocket(bundlerBaseUrl?: string): Promise<TradeEventEmitter>;
    /**
     * Disconnects the global socket connection and cleans up resources.
     */
    disconnectEventSocket(): void;
    /**
     * Checks if the global socket connection is active.
     * @returns True if connected, false otherwise.
     */
    eventSocketConnected(): boolean;
    /**
     * Registers a transaction ID for waiting and timeout handling.
     * @param txId - The transaction ID to register.
     * @param timeoutMs - Timeout in milliseconds.
     */
    registerTxId(txId: string, timeoutMs: number): void;
    /**
     * Waits for a transaction to complete.
     * @param txId - The transaction ID to wait for.
     * @returns Promise that resolves when the transaction completes.
     */
    wait(txId: string): Promise<{
        txId: string;
        transactionHash: string;
        Data: Record<string, unknown>;
    }>;
    /**
     * Internal handler for socket messages.
     * @param response - The bundler response.
     * @param txId - The transaction ID.
     */
    private internalHandleSocketMessage;
}

interface QuoteExactAmountRawResponse {
    amount0: string;
    amount1: string;
    currentSqrtPrice: string;
    newSqrtPrice: string;
}
interface QuoteExactAmountResponse {
    amount0: BigNumber;
    amount1: BigNumber;
    currentSqrtPrice: SqrtPrice;
    newSqrtPrice: SqrtPrice;
}
interface GetPoolDataRawResponse {
    bitmap: Record<string, string>;
    fee: number;
    feeGrowthGlobal0: string;
    feeGrowthGlobal1: string;
    grossPoolLiquidity: string;
    liquidity: string;
    maxLiquidityPerTick: string;
    protocolFees: number;
    protocolFeesToken0: string;
    protocolFeesToken1: string;
    sqrtPrice: string;
    tickSpacing: number;
    token0: string;
    token0ClassKey: {
        additionalKey: string;
        category: string;
        collection: string;
        type: string;
    };
    token1: string;
    token1ClassKey: {
        additionalKey: string;
        category: string;
        collection: string;
        type: string;
    };
}
interface GetPoolDataResponse {
    bitmap: Record<string, string>;
    fee: number;
    feeGrowthGlobal0: BigNumber;
    feeGrowthGlobal1: BigNumber;
    grossPoolLiquidity: BigNumber;
    liquidity: BigNumber;
    maxLiquidityPerTick: BigNumber;
    protocolFees: number;
    protocolFeesToken0: BigNumber;
    protocolFeesToken1: BigNumber;
    sqrtPrice: SqrtPrice;
    tickSpacing: number;
    token0: string;
    token0ClassKey: {
        additionalKey: string;
        category: string;
        collection: string;
        type: string;
    };
    token1: string;
    token1ClassKey: {
        additionalKey: string;
        category: string;
        collection: string;
        type: string;
    };
}
interface TransactionPendingResponse {
    data: string;
    message: string;
    error: boolean;
}

declare class Pools {
    private readonly gatewayBaseUrl;
    private readonly dexContractBasePath;
    private readonly httpClient;
    constructor(gatewayBaseUrl: string, dexContractBasePath: string, httpClient: HttpClient);
    /**
     * Gets pool data for a specific token pair and fee tier.
     */
    getPoolData(token0: GalaChainTokenClassKey | string, token1: GalaChainTokenClassKey | string, fee: number): Promise<GetPoolDataResponse>;
    /**
     * Calculates the nearest valid tick value for a given price.
     */
    calculateTicksForPrice(price: PriceIn, tickSpacing: number): number;
    calculatePriceForTicks(tick: number): Price;
    /**
     * Calculates the current spot price of a pool based on sqrt price.
     * Price is defined as the amount of outToken you would receive for 1 inToken.
     */
    calculateSpotPrice(inToken: GalaChainTokenClassKey | string, outToken: GalaChainTokenClassKey | string, poolSqrtPrice: SqrtPriceIn): BigNumber;
}

/**
 * Fee tiers for pools.
 */
declare enum FEE_TIER {
    /** 0.05% fee tier */
    PERCENT_00_05 = 500,
    /** 0.3% fee tier */
    PERCENT_00_30 = 3000,
    /** 1.0% fee tier */
    PERCENT_01_00 = 10000
}

/**
 * Handles position management operations for liquidity positions.
 */
declare class Positions {
    private readonly gatewayBaseUrl;
    private readonly dexContractBasePath;
    private readonly options?;
    private readonly httpClient;
    private readonly bundlerService;
    private readonly poolService;
    constructor(gatewayBaseUrl: string, dexContractBasePath: string, bundlerService: Bundler, poolService: Pools, httpClient: HttpClient, options?: {
        walletAddress?: string | undefined;
    } | undefined);
    /**
     * Get all liquidity positions for a specific wallet address.
     * @param ownerAddress - The wallet address to get positions for.
     * @param limit - Maximum number of positions to return.
     * @param bookmark - Pagination bookmark for retrieving additional results. If you call this function and it returns a bookmark that is not an empty string, you can pass that bookmark as this parameter in a subsequent call to fetch the next page.
     * @returns User positions and pagination bookmark
     * @example
     * ```typescript
     * const positions = await gSwap.positions.getUserPositions('eth|123...abc');
     * console.log(positions);
     * ```
     */
    getUserPositions(ownerAddress: string, limit?: number, bookmark?: string): Promise<{
        bookmark: string;
        positions: GetUserPositionsResult[];
    }>;
    /**
     * Gets detailed information about a specific liquidity position.
     * @param ownerAddress - The wallet address that owns the position.
     * @param position - Position parameters including tokens, fee, and tick range.
     * @param position.token0ClassKey - The first token in the position.
     * @param position.token1ClassKey - The second token in the position.
     * @param position.fee - The pool fee tier.
     * @param position.tickLower - The lower tick of the position range.
     * @param position.tickUpper - The upper tick of the position range.
     * @returns Detailed position information.
     * @example
     * ```typescript
     * const position = await gSwap.positions.getPosition('eth|123...abc', {
     *   token0ClassKey: 'GALA|Unit|none|none',
     *   token1ClassKey: 'GUSDC|Unit|none|none',
     *   fee: 500,
     *   tickLower: -6000,
     *   tickUpper: 6000
     * });
     * console.log('Position:', position);
     * ```
     */
    getPosition(ownerAddress: string, position: {
        token0ClassKey: GalaChainTokenClassKey | string;
        token1ClassKey: GalaChainTokenClassKey | string;
        fee: number;
        tickLower: number;
        tickUpper: number;
    }): Promise<GetPositionResult>;
    /**
     * Estimates the token amounts that would be received from removing liquidity from a position.
     * @param args - Parameters for estimating liquidity removal.
     * @param args.ownerAddress - The wallet address that owns the position.
     * @param args.positionId - The position identifier.
     * @param args.token0 - The first token in the pair.
     * @param args.token1 - The second token in the pair.
     * @param args.fee - The pool fee tier.
     * @param args.tickLower - The lower tick of the position range.
     * @param args.tickUpper - The upper tick of the position range.
     * @param args.amount - The amount of liquidity to remove.
     * @returns Estimated token amounts that would be received.
     * @example
     * ```typescript
     * const estimation = await gSwap.positions.estimateRemoveLiquidity({
     *   ownerAddress: 'client|635f048ab243d7eb7f5ba044',
     *   positionId: '210f8e4dd1bbe1b4af4b977330ee7e4b68bc716f66e39c87a60fff0976ded3ea',
     *   token0: 'GALA|Unit|none|none',
     *   token1: 'GUSDT|Unit|none|none',
     *   fee: 3000,
     *   tickLower: -41100,
     *   tickUpper: -40080,
     *   amount: '1491.973332758921980256'
     * });
     * console.log('Estimated tokens:', estimation);
     * ```
     */
    estimateRemoveLiquidity(args: {
        ownerAddress: string;
        positionId: string;
        token0: GalaChainTokenClassKey | string;
        token1: GalaChainTokenClassKey | string;
        fee: number;
        tickLower: number;
        tickUpper: number;
        amount: NumericAmount;
    }): Promise<{
        amount0: BigNumber;
        amount1: BigNumber;
    }>;
    /**
     * Gets detailed information about a liquidity position by its ID.
     * @param ownerAddress - The wallet address that owns the position.
     * @param positionId - The unique identifier of the position.
     * @returns Detailed position information, or undefined if not found.
     * @example
     * ```typescript
     * const position = await gSwap.positions.getPositionById('eth|123...abc', 'position-uuid-123');
     * if (position) {
     *   console.log('Position found:', position);
     * } else {
     *   console.log('Position not found');
     * }
     * ```
     */
    getPositionById(ownerAddress: string, positionId: string): Promise<GetPositionResult | undefined>;
    /**
     * Creates a new position or adds liquidity to a position, using a specific tick range. Consider using `addLiquidityByPrice()` instead unless you want to use ticks directly.
     * @param args - Parameters for adding liquidity.
     * @param args.walletAddress - The wallet address adding liquidity.
     * @param args.positionId - The position identifier. If you're creating a new position, this should be an empty string.
     * @param args.token0 - The first token in the pair.
     * @param args.token1 - The second token in the pair.
     * @param args.fee - The pool fee tier.
     * @param args.tickLower - The lower tick of the position range.
     * @param args.tickUpper - The upper tick of the position range.
     * @param args.amount0Desired - Desired (also maximum) amount of token0 to add.
     * @param args.amount1Desired - Desired (also maximum) amount of token1 to add.
     * @param args.amount0Min - Minimum amount of token0 to add (slippage protection).
     * @param args.amount1Min - Minimum amount of token1 to add (slippage protection).
     * @returns Pending transaction.
     * @example
     * ```typescript
     * const result = await gSwap.positions.addLiquidityByTicks({
     *   walletAddress: 'eth|123...abc',
     *   positionId: '',
     *   token0: 'GALA|Unit|none|none',
     *   token1: 'GUSDC|Unit|none|none',
     *   fee: 500,
     *   tickSpacing: 10,
     *   tickLower: -6000,
     *   tickUpper: 6000,
     *   amount0Desired: '100',
     *   amount1Desired: '50',
     *   amount0Min: '95',
     *   amount1Min: '47.5'
     * });
     * console.log('Liquidity added:', result);
     * ```
     */
    addLiquidityByTicks(args: {
        walletAddress?: string;
        positionId: string;
        token0: GalaChainTokenClassKey | string;
        token1: GalaChainTokenClassKey | string;
        fee: FEE_TIER;
        tickLower: number;
        tickUpper: number;
        amount0Desired: NumericAmount;
        amount1Desired: NumericAmount;
        amount0Min: NumericAmount;
        amount1Min: NumericAmount;
    }): Promise<PendingTransaction>;
    /**
     * Creates a new position or adds liquidity to a position, using a specified price range. Note that this method automatically converts your minPrice and maxPrice to ticks, rounding down if necessary.
     * @param args - Parameters for adding liquidity.
     * @param args.walletAddress - The wallet address adding liquidity.
     * @param args.positionId - The position identifier. This should be an empty string if you are creating a new position.
     * @param args.token0 - The first token in the pair.
     * @param args.token1 - The second token in the pair.
     * @param args.fee - The pool fee tier.
     * @param args.tickSpacing - The tick spacing for the pool.
     * @param args.minPrice - The minimum price for the position range.
     * @param args.maxPrice - The maximum price for the position range.
     * @param args.amount0Desired - Desired (also maximum) amount of token0 to add.
     * @param args.amount1Desired - Desired (also maximum) amount of token1 to add.
     * @param args.amount0Min - Minimum amount of token0 to add (slippage protection).
     * @param args.amount1Min - Minimum amount of token1 to add (slippage protection).
     * @returns Pending transaction.
     * @example
     * ```typescript
     * const result = await gSwap.positions.addLiquidityByPrice({
     *   walletAddress: 'eth|123...abc',
     *   positionId: '',
     *   token0: 'GALA|Unit|none|none',
     *   token1: 'GUSDC|Unit|none|none',
     *   fee: 500,
     *   tickSpacing: 10,
     *   minPrice: '0.45',
     *   maxPrice: '0.55',
     *   amount0Desired: '100',
     *   amount1Desired: '50',
     *   amount0Min: '95',
     *   amount1Min: '47.5'
     * });
     * console.log('Liquidity added with price range:', result);
     * ```
     */
    addLiquidityByPrice(args: {
        walletAddress?: string;
        positionId: string;
        token0: GalaChainTokenClassKey | string;
        token1: GalaChainTokenClassKey | string;
        fee: number;
        tickSpacing: number;
        minPrice: PriceIn;
        maxPrice: PriceIn;
        amount0Desired: NumericAmount;
        amount1Desired: NumericAmount;
        amount0Min: NumericAmount;
        amount1Min: NumericAmount;
    }): Promise<PendingTransaction>;
    /**
     * Removes liquidity from a position.
     * @param args - Parameters for removing liquidity.
     * @param args.walletAddress - The wallet address removing liquidity.
     * @param args.positionId - The position identifier.
     * @param args.token0 - The first token in the pair.
     * @param args.token1 - The second token in the pair.
     * @param args.fee - The pool fee tier.
     * @param args.tickLower - The lower tick of the position range.
     * @param args.tickUpper - The upper tick of the position range.
     * @param args.amount - The amount of liquidity to remove.
     * @param args.amount0Min - Minimum amount of token0 to receive (slippage protection, optional).
     * @param args.amount1Min - Minimum amount of token1 to receive (slippage protection, optional).
     * @returns Pending transaction.
     * @example
     * ```typescript
     * // Remove 50% of liquidity from a position
     * const result = await gSwap.positions.removeLiquidity({
     *   walletAddress: 'eth|123...abc',
     *   positionId: 'position-123',
     *   token0: 'GALA|Unit|none|none',
     *   token1: 'GUSDC|Unit|none|none',
     *   fee: 500,
     *   tickLower: -6000,
     *   tickUpper: 6000,
     *   amount: '50000000000000000000', // 50% of position liquidity
     *   amount0Min: '45',
     *   amount1Min: '22'
     * });
     * console.log('Liquidity removed:', result);
     * ```
     */
    removeLiquidity(args: {
        walletAddress?: string;
        positionId: string;
        token0: GalaChainTokenClassKey | string;
        token1: GalaChainTokenClassKey | string;
        fee: number;
        tickLower: number;
        tickUpper: number;
        amount: NumericAmount;
        amount0Min?: NumericAmount;
        amount1Min?: NumericAmount;
    }): Promise<PendingTransaction>;
    /**
     * Collects accumulated fees from a liquidity position.
     * @param args - Parameters for collecting fees.
     * @param args.walletAddress - The wallet address collecting fees.
     * @param args.positionId - The position identifier.
     * @param args.token0 - The first token in the pair.
     * @param args.token1 - The second token in the pair.
     * @param args.fee - The pool fee tier.
     * @param args.tickLower - The lower tick of the position range.
     * @param args.tickUpper - The upper tick of the position range.
     * @param args.amount0Requested - Desired amount of token0 fees to collect.
     * @param args.amount1Requested - Desired amount of token1 fees to collect.
     * @returns Pending transaction.
     * @example
     * ```typescript
     * // Collect all accumulated fees from a position
     * const result = await gSwap.positions.collectPositionFees({
     *   walletAddress: 'eth|123...abc',
     *   positionId: 'position-123',
     *   token0: 'GALA|Unit|none|none',
     *   token1: 'GUSDC|Unit|none|none',
     *   fee: 500,
     *   tickLower: -6000,
     *   tickUpper: 6000,
     *   amount0Requested: '1000000000000000000', // Max fees available
     *   amount1Requested: '500000000' // Max fees available
     * });
     * console.log('Fees collected:', result);
     * ```
     */
    collectPositionFees(args: {
        walletAddress?: string;
        positionId: string;
        token0: GalaChainTokenClassKey | string;
        token1: GalaChainTokenClassKey | string;
        fee: number;
        tickLower: number;
        tickUpper: number;
        amount0Requested: NumericAmount;
        amount1Requested: NumericAmount;
    }): Promise<PendingTransaction>;
    calculateOptimalPositionSize(tokenAmount: NumericAmount, spotPrice: NumericAmount, lowerPrice: NumericAmount, upperPrice: NumericAmount, tokenDecimals: number, otherTokenDecimals: number): BigNumber;
    private sendUserPositionsRequest;
    private sendPositionRequest;
}

/**
 * Handles quote operations for token swaps.
 */
declare class Quoting {
    private readonly gatewayBaseUrl;
    private readonly dexContractBasePath;
    private readonly httpClient;
    constructor(gatewayBaseUrl: string, dexContractBasePath: string, httpClient?: HttpClient);
    /**
     * Gets a quote for an exact amount of token being sold.
     * @param tokenIn - The input token to sell.
     * @param tokenOut - The output token to buy.
     * @param amountIn - The exact amount of input tokens you want to sell.
     * @param fee - The pool fee tier. If not specified, will check all available fee tiers and return the best quote.
     * @returns The expected number of tokens you will receive (buy) when/if you execute the swap.
     */
    quoteExactInput(tokenIn: GalaChainTokenClassKey | string, tokenOut: GalaChainTokenClassKey | string, amountIn: NumericAmount, fee?: FEE_TIER): Promise<GetQuoteResult>;
    /**
     * Gets a quote for an exact amount of tokens being bought.
     * @param tokenIn - The input token sell.
     * @param tokenOut - The output token to buy.
     * @param amountOut - The exact amount of output tokens you want to buy.
     * @param fee - The pool fee tier. If not specified, will check all available fee tiers and return the best quote.
     * @returns The expected number of tokens you will need to sell (input) to receive the specified amount of output tokens.
     */
    quoteExactOutput(tokenIn: GalaChainTokenClassKey | string, tokenOut: GalaChainTokenClassKey | string, amountOut: string | number | BigNumber, fee?: FEE_TIER): Promise<GetQuoteResult>;
    private getSingleQuote;
    private getSingleQuoteExactInput;
    private getSingleQuoteExactOutput;
    private sendQuoteRequest;
}

/**
 * Service for handling token swap operations.
 */
declare class Swaps {
    private readonly bundlerService;
    private readonly options?;
    constructor(bundlerService: Bundler, options?: {
        walletAddress?: string | undefined;
    } | undefined);
    /**
     * Executes a token swap transaction.
     * @param walletAddress - The wallet address executing the swap.
     * @param tokenIn - The input token to sell.
     * @param tokenOut - The output token to buy.
     * @param fee - The pool fee tier.
     * @param amount - Swap parameters specifying either exact input or exact output.
     * @param amount.exactIn - For exact input swaps, the exact amount of input tokens to sell.
     * @param amount.amountOutMinimum - For exact input swaps, the minimum amount of output tokens to buy (slippage protection).
     * @param amount.exactOut - For exact output swaps, the exact amount of output tokens to buy.
     * @param amount.amountInMaximum - For exact output swaps, the maximum amount of input tokens to sell (slippage protection).
     * @returns Pending transaction.
     * @example
     * ```typescript
     * // Exact input swap: sell 100 GALA for USDC
     * const result = await swapsService.swap(
     *   'GALA|Unit|none|none',
     *   'GUSDC|Unit|none|none',
     *   500,
     *   { exactIn: '100', amountOutMinimum: '45' },
     *   'eth|123...abc', // your wallet address
     * );
     * console.log('Swap successful:', result);
     * ```
     */
    swap(tokenIn: GalaChainTokenClassKey | string, tokenOut: GalaChainTokenClassKey | string, fee: number, amount: {
        exactIn: NumericAmount;
        amountOutMinimum?: NumericAmount;
    } | {
        exactOut: NumericAmount;
        amountInMaximum?: NumericAmount;
    }, walletAddress?: string): Promise<PendingTransaction>;
}

/**
 * Main class for interacting with the gSwap decentralized exchange.
 * Provides methods for trading, liquidity management, and position handling.
 */
declare class GSwap {
    readonly gatewayBaseUrl: string;
    readonly dexContractBasePath: string;
    readonly tokenContractBasePath: string;
    readonly bundlerBaseUrl: string;
    readonly bundlingAPIBasePath: string;
    readonly dexBackendBaseUrl: string;
    readonly transactionWaitTimeoutMs: number;
    readonly signer?: GalaChainSigner | undefined;
    /**
     * Quoting functionality for price discovery and trade estimation.
     * Use this to get quotes for token swaps without executing transactions.
     *
     * @example
     * ```typescript
     * // Get the best quote across all fee tiers
     * const quote = await gSwap.quoting.quoteExactInput(tokenA, tokenB, amount);
     * ```
     */
    readonly quoting: Quoting;
    /**
     * Position management operations for liquidity positions.
     * Use this to manage liquidity positions including creation, modification, and fee collection.
     *
     * @example
     * ```typescript
     * // Get all user positions
     * const positions = await gSwap.positions.getUserPositions('eth|123...abc');
     *
     * // Add liquidity to a position using price range
     * const result = await gSwap.positions.addLiquidityByPrice({
     *   walletAddress: 'eth|123...abc',
     *   positionId: '',
     *   token0: 'GALA|Unit|none|none',
     *   token1: 'GUSDC|Unit|none|none',
     *   fee: 500,
     *   tickSpacing: 10,
     *   minPrice: '0.45',
     *   maxPrice: '0.55',
     *   amount0Desired: '100',
     *   amount1Desired: '50',
     *   amount0Min: '95',
     *   amount1Min: '47.5'
     * });
     * ```
     */
    readonly positions: Positions;
    /**
     * Token swap operations for trading tokens.
     * Use this to execute token swaps on the DEX.
     *
     * @example
     * ```typescript
     * // Execute an exact input swap: sell 100 GALA for USDC
     * const result = await gSwap.swaps.swap(
     *   'GALA|Unit|none|none',
     *   'GUSDC|Unit|none|none',
     *   500,
     *   { exactIn: '100', amountOutMinimum: '45' },
     *   'eth|123...abc', // your wallet address
     * );
     * ```
     */
    readonly swaps: Swaps;
    /**
     * User asset management operations.
     * Use this to retrieve user token balances and asset information.
     *
     * @example
     * ```typescript
     * // Get user assets with pagination
     * const assets = await gSwap.assets.getUserAssets('eth|123...abc', 1, 20);
     * console.log(`User has ${assets.count} different tokens`);
     * ```
     */
    readonly assets: Assets;
    /**
     * Event management operations for real-time socket connections.
     * Use this to manage event streaming and transaction status updates.
     *
     * @example
     * ```typescript
     * // Connect to event socket for transaction updates
     * await GSwap.events.connectEventSocket();
     *
     * // Check if socket is connected
     * const isConnected = GSwap.events.eventSocketConnected();
     * ```
     */
    static readonly events: Events;
    private readonly httpClient;
    private readonly httpRequestor;
    private readonly bundler;
    readonly pools: Pools;
    /**
     * Creates a new SDK instance.
     * @param options - Customization options.
     * @param options.signer - The signer to use for authenticated operations. Required if you use any functionality that creates transactions (such as swapping). Not required for readonly operations.
     * @param options.gatewayBaseUrl - Base URL for the GalaChain Gateway API.
     * @param options.dexContractBasePath - Base path for DEX contract API endpoints, within the GalaChain Gateway API.
     * @param options.tokenContractBasePath - Base path for token contract API endpoints, within the GalaChain Gateway API.
     * @param options.bundlerBaseUrl - Base URL for the DEX transaction bundling API.
     * @param options.bundlingAPIBasePath - Base path for transaction bundling API endpoints.
     * @param options.dexBackendBaseUrl - Base URL for the DEX backend API (for user assets and other data).
     * @param options.httpRequestor - Custom HTTP requestor to use for API calls. Defaults to the global `fetch` function.
     * @param options.transactionWaitTimeoutMs - Timeout in milliseconds for waiting for transactions to complete. Defaults to 300,000 milliseconds (five minutes).
     * @param options.walletAddress - Optional default wallet address for operations that require a wallet address (e.x. swapping). If not provided, you must specify the wallet address in each method call.
     */
    constructor(options?: {
        signer?: GalaChainSigner | undefined;
        gatewayBaseUrl?: string | undefined;
        dexContractBasePath?: string | undefined;
        tokenContractBasePath?: string | undefined;
        bundlerBaseUrl?: string | undefined;
        bundlingAPIBasePath?: string | undefined;
        dexBackendBaseUrl?: string | undefined;
        transactionWaitTimeoutMs?: number | undefined;
        walletAddress?: string | undefined;
        httpRequestor?: HttpRequestor | undefined;
    });
}

declare class GSwapSDKError extends Error {
    readonly code: string;
    readonly details?: Record<string, unknown> | undefined;
    constructor(message: string, code: string, details?: Record<string, unknown> | undefined);
    static noSignerError(): GSwapSDKError;
    static fromErrorResponse(url: string, response: HTTPResponse): Promise<GSwapSDKError>;
    static incorrectTokenOrderingError(specifiedToken0: GalaChainTokenClassKey | string, specifiedToken1: GalaChainTokenClassKey | string): GSwapSDKError;
    static transactionWaitTimeoutError(txId: string): GSwapSDKError;
    static transactionWaitFailedError(txId: string, detail: Record<string, unknown>): GSwapSDKError;
    static socketConnectionRequiredError(): GSwapSDKError;
    static noPoolAvailableError(tokenIn: GalaChainTokenClassKey | string, tokenOut: GalaChainTokenClassKey | string, fee?: number): GSwapSDKError;
}

declare function stringifyTokenClassKey(tokenClassKey: GalaChainTokenClassKey | string, separator?: string): string;
declare function parseTokenClassKey(tokenClassKey: string | GalaChainTokenClassKey): GalaChainTokenClassKey;
declare function compareTokens(first: GalaChainTokenClassKey | string, second: GalaChainTokenClassKey | string): number;
declare function getTokenOrdering<TAttributesType = undefined>(first: GalaChainTokenClassKey | string, second: GalaChainTokenClassKey | string, assertCorrectness: boolean, token1Data?: TAttributesType, token2Data?: TAttributesType): {
    token0: string | GalaChainTokenClassKey;
    token1: string | GalaChainTokenClassKey;
    zeroForOne: true;
    token0Attributes: TAttributesType | undefined;
    token1Attributes: TAttributesType | undefined;
} | {
    token0: string | GalaChainTokenClassKey;
    token1: string | GalaChainTokenClassKey;
    zeroForOne: false;
    token0Attributes: TAttributesType | undefined;
    token1Attributes: TAttributesType | undefined;
};

declare function validateNumericAmount(amount: NumericAmount, parameterName: string, allowZero?: boolean): void;
declare function validatePriceValues(spotPrice: NumericAmount, lowerPrice: NumericAmount, upperPrice: NumericAmount): void;
declare function validateTokenDecimals(decimals: number, parameterName: string): void;
declare function validateTickRange(tickLower: number, tickUpper: number): void;
declare function validateFee(fee: number): void;
declare function validateTickSpacing(tickSpacing: number): void;
declare function validateWalletAddress(address?: string): asserts address is string;

export { Assets, Bundler, type BundlerRequest, type BundlerResponse, EventSocketClient, Events, FEE_TIER, GSwap, GSwapSDKError, type GalaChainSigner, type GalaChainTokenClassKey, GalaWalletSigner, type GetPoolDataRawResponse, type GetPoolDataResponse, type GetPositionResult, type GetQuoteResult, type GetUserAssetsResult, type GetUserPositionsResult, type NumericAmount, PendingTransaction, Pools, Positions, type Price, type PriceIn, PrivateKeySigner, type QuoteExactAmountRawResponse, type QuoteExactAmountResponse, Quoting, type SqrtPrice, type SqrtPriceIn, Swaps, TradeEventEmitter, type TransactionPendingResponse, type UserAsset, compareTokens, getTokenOrdering, parseTokenClassKey, stringifyTokenClassKey, validateFee, validateNumericAmount, validatePriceValues, validateTickRange, validateTickSpacing, validateTokenDecimals, validateWalletAddress };
