// src/utils/validation.ts
import BigNumber from "bignumber.js";

// src/classes/gswap_sdk_error.ts
var GSwapSDKError = class _GSwapSDKError extends Error {
  constructor(message, code, details) {
    super(message);
    this.code = code;
    this.details = details;
    this.name = "GSwapSDKError";
  }
  static noSignerError() {
    return new _GSwapSDKError(
      "This method requires a signer. Please provide a signer to the GSwap constructor.",
      "NO_SIGNER"
    );
  }
  static async fromErrorResponse(url, response) {
    const bodyText = await response.text();
    const bodyJson = (() => {
      try {
        return JSON.parse(bodyText);
      } catch {
        return void 0;
      }
    })();
    const errorKey = typeof bodyJson === "object" && bodyJson && "error" in bodyJson && typeof bodyJson.error === "object" && bodyJson.error && "ErrorKey" in bodyJson.error && typeof bodyJson.error.ErrorKey === "string" ? bodyJson.error.ErrorKey : void 0;
    const message = typeof bodyJson === "object" && bodyJson && "error" in bodyJson && typeof bodyJson.error === "object" && bodyJson.error && "Message" in bodyJson.error && typeof bodyJson.error.Message === "string" ? bodyJson.error.Message : void 0;
    if (errorKey && message) {
      return new _GSwapSDKError(`GalaChain Error ${errorKey} from ${url}: ${message}`, errorKey, {
        message,
        errorKey,
        status: response.status,
        body: bodyJson,
        url
      });
    }
    return new _GSwapSDKError(`Unexpected HTTP Error ${response.status} from ${url}`, "HTTP_ERROR", {
      status: response.status,
      body: bodyJson ?? bodyText,
      url
    });
  }
  static incorrectTokenOrderingError(specifiedToken0, specifiedToken1) {
    return new _GSwapSDKError(
      "Token ordering is incorrect. token0 should sort below token1.",
      "INCORRECT_TOKEN_ORDERING",
      {
        specifiedToken0,
        specifiedToken1
      }
    );
  }
  static transactionWaitTimeoutError(txId) {
    return new _GSwapSDKError("Transaction wait timed out.", "TRANSACTION_WAIT_TIMEOUT", {
      txId
    });
  }
  static transactionWaitFailedError(txId, detail) {
    const transactionHash = "transactionId" in detail && typeof detail.transactionId === "string" ? detail.transactionId : void 0;
    const { transactionId, ...rest } = detail;
    return new _GSwapSDKError("Transaction wait failed.", "TRANSACTION_WAIT_FAILED", {
      txId,
      transactionHash,
      ...rest
    });
  }
  static socketConnectionRequiredError() {
    return new _GSwapSDKError(
      "This method requires a socket connection. Did you call connectSocket()?",
      "SOCKET_CONNECTION_REQUIRED"
    );
  }
  static noPoolAvailableError(tokenIn, tokenOut, fee) {
    const message = fee !== void 0 ? `No pool available for the specified token pair at fee tier ${fee}` : "No pools available for the specified token pair";
    return new _GSwapSDKError(message, "NO_POOL_AVAILABLE", {
      tokenIn,
      tokenOut,
      fee
    });
  }
};

// src/utils/validation.ts
function validateNumericAmount(amount, parameterName, allowZero = false) {
  const bnAmount = BigNumber(amount);
  if (!bnAmount.isFinite()) {
    throw new GSwapSDKError(
      `Invalid ${parameterName}: must be a finite number`,
      "VALIDATION_ERROR",
      {
        type: "INVALID_NUMERIC_AMOUNT",
        parameterName,
        value: amount,
        reason: "not_finite"
      }
    );
  }
  if (!allowZero && bnAmount.isZero()) {
    throw new GSwapSDKError(`Invalid ${parameterName}: must be positive`, "VALIDATION_ERROR", {
      type: "INVALID_NUMERIC_AMOUNT",
      parameterName,
      value: amount,
      reason: "zero_not_allowed"
    });
  }
  if (bnAmount.isNegative()) {
    throw new GSwapSDKError(
      `Invalid ${parameterName}: must be ${allowZero ? "non-negative" : "positive"}`,
      "VALIDATION_ERROR",
      {
        type: "INVALID_NUMERIC_AMOUNT",
        parameterName,
        value: amount,
        reason: "negative"
      }
    );
  }
}
function validatePriceValues(spotPrice, lowerPrice, upperPrice) {
  const bnSpotPrice = BigNumber(spotPrice);
  const bnLowerPrice = BigNumber(lowerPrice);
  let bnUpperPrice = BigNumber(upperPrice);
  bnUpperPrice = bnUpperPrice.isFinite() ? bnUpperPrice : BigNumber(1e18);
  if (!bnSpotPrice.isFinite() || !bnLowerPrice.isFinite() || !bnUpperPrice.isFinite() || !bnSpotPrice.isPositive() || !bnLowerPrice.isPositive() || !bnUpperPrice.isPositive()) {
    throw new GSwapSDKError(
      "Invalid price values: all prices must be finite and positive",
      "VALIDATION_ERROR",
      {
        type: "INVALID_PRICE_VALUES",
        spotPrice,
        lowerPrice,
        upperPrice
      }
    );
  }
  if (bnLowerPrice.isGreaterThan(bnUpperPrice)) {
    throw new GSwapSDKError(
      "Invalid price range: lower price must be less than or equal to upper price",
      "VALIDATION_ERROR",
      {
        type: "INVALID_PRICE_RANGE",
        lowerPrice,
        upperPrice
      }
    );
  }
}
function validateTokenDecimals(decimals, parameterName) {
  if (decimals < 0 || !Number.isInteger(decimals)) {
    throw new GSwapSDKError(
      `Invalid ${parameterName}: must be a non-negative integer`,
      "VALIDATION_ERROR",
      {
        type: "INVALID_TOKEN_DECIMALS",
        parameterName,
        value: decimals
      }
    );
  }
}
function validateTickRange(tickLower, tickUpper) {
  if (!Number.isInteger(tickLower) || !Number.isInteger(tickUpper)) {
    throw new GSwapSDKError("Invalid tick values: ticks must be integers", "VALIDATION_ERROR", {
      type: "INVALID_TICK_VALUES",
      tickLower,
      tickUpper
    });
  }
  if (tickLower >= tickUpper) {
    throw new GSwapSDKError(
      "Invalid tick range: tickLower must be less than tickUpper",
      "VALIDATION_ERROR",
      {
        type: "INVALID_TICK_RANGE",
        tickLower,
        tickUpper
      }
    );
  }
  if (tickLower < -886800 || tickUpper > 886800) {
    throw new GSwapSDKError(
      "Invalid tick range: ticks must be between -886800 and 886800",
      "VALIDATION_ERROR",
      {
        type: "INVALID_TICK_BOUNDS",
        tickLower,
        tickUpper,
        minTick: -886800,
        maxTick: 886800
      }
    );
  }
}
function validateFee(fee) {
  if (!Number.isInteger(fee) || fee < 0) {
    throw new GSwapSDKError("Invalid fee: must be a non-negative integer", "VALIDATION_ERROR", {
      type: "INVALID_FEE",
      value: fee
    });
  }
}
function validateTickSpacing(tickSpacing) {
  if (!Number.isInteger(tickSpacing) || tickSpacing <= 0) {
    throw new GSwapSDKError(
      "Invalid tick spacing: must be a positive integer",
      "VALIDATION_ERROR",
      {
        type: "INVALID_TICK_SPACING",
        value: tickSpacing
      }
    );
  }
}
function validateWalletAddress(address) {
  if (address === void 0) {
    throw new GSwapSDKError(
      "Invalid wallet address: No wallet address provided",
      "VALIDATION_ERROR",
      {
        type: "MISSING_WALLET_ADDRESS",
        hint: "Either provide a wallet address to the function you are calling, or set one when instantiating GSwapSDK"
      }
    );
  }
  if (!address || typeof address !== "string" || address.trim().length === 0) {
    throw new GSwapSDKError(
      "Invalid wallet address: must be a non-empty string",
      "VALIDATION_ERROR",
      {
        type: "INVALID_WALLET_ADDRESS",
        value: address
      }
    );
  }
}

// src/classes/assets.ts
var Assets = class {
  constructor(dexBackendBaseUrl, httpClient) {
    this.dexBackendBaseUrl = dexBackendBaseUrl;
    this.httpClient = httpClient;
  }
  /**
   * Gets all token assets owned by a user with their balances.
   * @param ownerAddress - The wallet address to get assets for.
   * @param page - Page number for pagination (default: 1).
   * @param limit - Maximum number of assets to return per page (default: 10).
   * @returns User assets including token information and balances.
   * @example
   * ```typescript
   * const assets = await assetsService.getUserAssets('eth|123...abc', 1, 20);
   * console.log(`User has ${assets.count} different tokens`);
   * assets.tokens.forEach(token => {
   *   console.log(`${token.symbol}: ${token.quantity}`);
   * });
   * ```
   */
  async getUserAssets(ownerAddress, page = 1, limit = 10) {
    validateWalletAddress(ownerAddress);
    if (!Number.isInteger(page) || page < 1) {
      throw new Error("Invalid page: must be a positive integer");
    }
    if (!Number.isInteger(limit) || limit < 1 || limit > 100) {
      throw new Error("Invalid limit: must be an integer between 1 and 100");
    }
    const json = await this.httpClient.sendGetRequest(this.dexBackendBaseUrl, "/user/assets", "", {
      address: ownerAddress,
      page: page.toString(),
      limit: limit.toString()
    });
    return {
      tokens: json.data.token.map((token) => ({
        ...token,
        decimals: parseInt(token.decimals, 10)
      })) || [],
      count: json.data.count || 0
    };
  }
};

// src/classes/bundler.ts
import crypto from "crypto";

// src/utils/debug.ts
import debug from "debug";
var debugLog = debug("GSWAP_SDK");

// src/classes/event_socket_client.ts
import { EventEmitter } from "events";
import { io } from "socket.io-client";
var TradeEventEmitter = class extends EventEmitter {
};
var EventSocketClient = class extends TradeEventEmitter {
  socket = null;
  bundlerUrl;
  constructor(bundlerUrl) {
    super();
    this.bundlerUrl = bundlerUrl;
  }
  connect() {
    return new Promise((resolve, reject) => {
      var _a;
      if ((_a = this.socket) == null ? void 0 : _a.connected) {
        resolve();
        return;
      }
      this.socket = io(this.bundlerUrl, {
        transports: ["websocket"],
        autoConnect: true
      });
      this.socket.on("connect", () => {
        console.log("Connected to bundler socket:", this.bundlerUrl);
        this.emit("connect");
        resolve();
      });
      this.socket.on("connect_error", (error) => {
        console.error("Failed to connect to bundler socket:", error);
        this.emit("error", error);
        reject(error);
      });
      this.socket.on("disconnect", (reason) => {
        console.log("Disconnected from bundler socket:", reason);
        this.emit("disconnect", reason);
      });
      this.socket.onAny((eventName, ...args) => {
        var _a2;
        if (typeof eventName === "string") {
          const [responseData] = args;
          this.emit("transaction", eventName, {
            ...responseData,
            transactionHash: (_a2 = responseData.data) == null ? void 0 : _a2.transactionId
          });
        }
      });
    });
  }
  disconnect() {
    if (this.socket) {
      this.socket.disconnect();
      this.socket = null;
    }
  }
  isConnected() {
    var _a;
    return ((_a = this.socket) == null ? void 0 : _a.connected) ?? false;
  }
};

// src/classes/tx_waiter.ts
var TransactionWaiter = class {
  enabled = false;
  promiseInfoForTxId = /* @__PURE__ */ new Map();
  setEnabled(enabled) {
    this.enabled = enabled;
    if (!enabled) {
      for (const [txId, promiseInfo] of this.promiseInfoForTxId.entries()) {
        clearTimeout(promiseInfo.timeoutId);
        promiseInfo.reject(
          GSwapSDKError.transactionWaitFailedError(txId, {
            message: "Transaction waiter disabled"
          })
        );
      }
      this.promiseInfoForTxId.clear();
    }
  }
  registerTxId(txId, timeoutMs) {
    if (this.promiseInfoForTxId.has(txId)) {
      throw new GSwapSDKError(
        `Transaction ID is already registered`,
        "TRANSACTION_ID_ALREADY_REGISTERED",
        { txId }
      );
    }
    if (!this.enabled) {
      return;
    }
    let resolve;
    let reject;
    const promise = new Promise((res, rej) => {
      resolve = res;
      reject = rej;
    });
    const timeoutId = setTimeout(() => {
      const promiseInfo = this.promiseInfoForTxId.get(txId);
      if (promiseInfo) {
        if (promiseInfo.waited) {
          promiseInfo.reject(GSwapSDKError.transactionWaitTimeoutError(txId));
        } else {
          promiseInfo.resolve({ txId, transactionHash: txId, Data: {} });
        }
        this.promiseInfoForTxId.delete(txId);
      }
    }, timeoutMs);
    this.promiseInfoForTxId.set(txId, {
      promise,
      resolve,
      reject,
      timeoutId,
      waited: false
    });
  }
  wait(txId) {
    const promise = this.promiseInfoForTxId.get(txId);
    if (!promise) {
      throw new GSwapSDKError(
        `Transaction ID is not registered for waiting`,
        "TRANSACTION_ID_NOT_REGISTERED",
        {
          txId
        }
      );
    }
    promise.waited = true;
    return promise.promise;
  }
  notifySuccess(txId, data) {
    const promiseInfo = this.promiseInfoForTxId.get(txId);
    if (!promiseInfo) {
      return;
    }
    clearTimeout(promiseInfo.timeoutId);
    promiseInfo.resolve({
      txId,
      transactionHash: data.transactionId,
      Data: data.Data
    });
    this.promiseInfoForTxId.delete(txId);
  }
  notifyFailure(txId, detail) {
    const promiseInfo = this.promiseInfoForTxId.get(txId);
    if (!promiseInfo) {
      return;
    }
    clearTimeout(promiseInfo.timeoutId);
    if (promiseInfo.waited) {
      promiseInfo.reject(GSwapSDKError.transactionWaitFailedError(txId, detail));
    } else {
      promiseInfo.resolve({ txId, transactionHash: txId, Data: {} });
    }
    this.promiseInfoForTxId.delete(txId);
  }
};

// src/classes/events.ts
var Events = class _Events {
  globalSocketClient;
  globalWaitHelper = new TransactionWaiter();
  connectionPromise;
  static instance = new _Events();
  static tradeEventEmitterConstructor = EventSocketClient;
  /**
   * Establishes a global socket connection for real-time event streaming.
   * This connection is shared across all service instances.
   * @param bundlerBaseUrl - Optional bundler base URL. If not provided, uses default.
   * @returns The connected EventSocketClient.
   * @example
   * ```typescript
   * await eventsService.connectEventSocket();
   *
   * // Socket is now available for transaction updates
   * ```
   */
  async connectEventSocket(bundlerBaseUrl) {
    var _a;
    if (this.connectionPromise) {
      return this.connectionPromise;
    }
    if ((_a = this.globalSocketClient) == null ? void 0 : _a.isConnected()) {
      return this.globalSocketClient;
    }
    const url = bundlerBaseUrl ?? "https://bundle-backend-prod1.defi.gala.com";
    this.connectionPromise = (async () => {
      const client = new _Events.tradeEventEmitterConstructor(url);
      await client.connect();
      if (!this.globalWaitHelper) {
        this.globalWaitHelper = new TransactionWaiter();
      }
      client.on("transaction", this.internalHandleSocketMessage.bind(this));
      return client;
    })();
    this.globalSocketClient = await this.connectionPromise;
    this.connectionPromise = void 0;
    this.globalWaitHelper.setEnabled(true);
    return this.globalSocketClient;
  }
  /**
   * Disconnects the global socket connection and cleans up resources.
   */
  disconnectEventSocket() {
    if (this.globalSocketClient) {
      this.globalSocketClient.off("transaction", this.internalHandleSocketMessage.bind(this));
      this.globalSocketClient.disconnect();
      this.globalSocketClient = void 0;
      this.globalWaitHelper.setEnabled(false);
    }
  }
  /**
   * Checks if the global socket connection is active.
   * @returns True if connected, false otherwise.
   */
  eventSocketConnected() {
    var _a;
    return ((_a = this.globalSocketClient) == null ? void 0 : _a.isConnected()) ?? false;
  }
  /**
   * Registers a transaction ID for waiting and timeout handling.
   * @param txId - The transaction ID to register.
   * @param timeoutMs - Timeout in milliseconds.
   */
  registerTxId(txId, timeoutMs) {
    this.globalWaitHelper.registerTxId(txId, timeoutMs);
  }
  /**
   * Waits for a transaction to complete.
   * @param txId - The transaction ID to wait for.
   * @returns Promise that resolves when the transaction completes.
   */
  async wait(txId) {
    if (!this.eventSocketConnected()) {
      throw GSwapSDKError.socketConnectionRequiredError();
    }
    return this.globalWaitHelper.wait(txId);
  }
  /**
   * Internal handler for socket messages.
   * @param response - The bundler response.
   * @param txId - The transaction ID.
   */
  internalHandleSocketMessage(txId, response) {
    if (response.status === "PROCESSED") {
      this.globalWaitHelper.notifySuccess(txId, response.data);
    } else if (response.status === "FAILED") {
      this.globalWaitHelper.notifyFailure(txId, response.data);
    } else {
      debugLog(`Unknown response status for transaction ${txId}:`, response.status);
    }
  }
};

// src/classes/pending_transaction.ts
var PendingTransaction = class {
  constructor(transactionId, message, error, waitDelegate) {
    this.transactionId = transactionId;
    this.message = message;
    this.error = error;
    this.waitDelegate = waitDelegate;
  }
  /**
   * Waits for the transaction to be confirmed.
   * This should be called immediately after receiving the PendingTransaction
   * to ensure proper event handling. If you delay calling this method and the
   * transaction confirms before you call this method, an error will be thrown.
   *
   * @returns A promise that resolves when the transaction is confirmed.
   */
  wait() {
    return this.waitDelegate();
  }
};

// src/classes/bundler.ts
function randomUUID() {
  if (globalThis.crypto) {
    return globalThis.crypto.randomUUID();
  }
  return crypto.randomUUID();
}
var Bundler = class {
  constructor(bundlerBaseUrl, bundlingAPIBasePath, transactionWaitTimeoutMs, signer, httpClient) {
    this.bundlerBaseUrl = bundlerBaseUrl;
    this.bundlingAPIBasePath = bundlingAPIBasePath;
    this.transactionWaitTimeoutMs = transactionWaitTimeoutMs;
    this.signer = signer;
    this.httpClient = httpClient;
  }
  async signObject(methodName, toSign) {
    if (!this.signer) {
      throw GSwapSDKError.noSignerError();
    }
    const withUniqueKey = {
      ...toSign,
      uniqueKey: toSign.uniqueKey ?? `galaswap - operation - ${randomUUID()}`
    };
    debugLog("Signing object for method", methodName, withUniqueKey);
    return this.signer.signObject(methodName, withUniqueKey);
  }
  async sendBundlerRequest(method, body, stringsInstructions) {
    if (!this.hasSigner()) {
      throw GSwapSDKError.noSignerError();
    }
    const requestBody = {
      method,
      signedDto: await this.signObject(method, body),
      stringsInstructions
    };
    debugLog("Sending bundler request", method, requestBody);
    const response = await this.httpClient.sendPostRequest(
      this.bundlerBaseUrl,
      this.bundlingAPIBasePath,
      "",
      requestBody
    );
    debugLog("Received bundler response", method, response);
    Events.instance.registerTxId(response.data, this.transactionWaitTimeoutMs);
    const transaction = new PendingTransaction(
      response.data,
      response.message,
      response.error,
      () => {
        return Events.instance.wait(response.data);
      }
    );
    return transaction;
  }
  hasSigner() {
    return this.signer !== void 0;
  }
};

// src/classes/http_client.ts
var HttpClient = class {
  constructor(httpRequestor = fetch) {
    this.httpRequestor = httpRequestor;
  }
  async sendRequest(method, baseUrl, basePath, endpoint, body) {
    const url = `${baseUrl}${basePath}${endpoint}`;
    debugLog(`Sending request to ${url} with body:`, body);
    const response = await this.httpRequestor(url, {
      method,
      headers: {
        "Content-Type": "application/json",
        "User-Agent": "GalaChain-SDK/0.0"
      },
      ...body ? { body: JSON.stringify(body) } : {}
    });
    if (!response.ok) {
      throw await GSwapSDKError.fromErrorResponse(url, response);
    }
    const json = await response.json();
    debugLog(`Response from ${baseUrl}${basePath}${endpoint}:`, json);
    return json;
  }
  async sendPostRequest(baseUrl, basePath, endpoint, body) {
    return this.sendRequest("POST", baseUrl, basePath, endpoint, body);
  }
  async sendGetRequest(baseUrl, basePath, endpoint, params) {
    const searchParams = params ? new URLSearchParams(params) : void 0;
    const endpointWithParams = searchParams ? `${endpoint}?${searchParams.toString()}` : endpoint;
    return this.sendRequest("GET", baseUrl, basePath, endpointWithParams, void 0);
  }
};

// src/classes/pools.ts
import BigNumber2 from "bignumber.js";

// src/utils/token.ts
function stringifyTokenClassKey(tokenClassKey, separator = "|") {
  if (typeof tokenClassKey === "string") {
    return tokenClassKey;
  }
  return `${tokenClassKey.collection}${separator}${tokenClassKey.category}${separator}${tokenClassKey.type}${separator}${tokenClassKey.additionalKey}`;
}
function parseTokenClassKey(tokenClassKey) {
  if (typeof tokenClassKey === "object") {
    return {
      collection: tokenClassKey.collection,
      category: tokenClassKey.category,
      type: tokenClassKey.type,
      additionalKey: tokenClassKey.additionalKey
    };
  }
  const [collection, category, type, additionalKey] = tokenClassKey.split("|");
  if (!collection || !category || !type || !additionalKey) {
    throw new GSwapSDKError(`Invalid token class key`, "INVALID_TOKEN_CLASS_KEY", {
      tokenClassKey
    });
  }
  return {
    collection,
    category,
    type,
    additionalKey
  };
}
function compareTokens(first, second) {
  return stringifyTokenClassKey(first).localeCompare(stringifyTokenClassKey(second));
}
function getTokenOrdering(first, second, assertCorrectness, token1Data, token2Data) {
  const zeroForOne = compareTokens(first, second) < 0;
  if (zeroForOne) {
    return {
      token0: first,
      token1: second,
      zeroForOne,
      token0Attributes: token1Data,
      token1Attributes: token2Data
    };
  } else {
    if (assertCorrectness) {
      throw GSwapSDKError.incorrectTokenOrderingError(first, second);
    }
    return {
      token0: second,
      token1: first,
      zeroForOne,
      token0Attributes: token2Data,
      token1Attributes: token1Data
    };
  }
}

// src/classes/pools.ts
var Pools = class {
  constructor(gatewayBaseUrl, dexContractBasePath, httpClient) {
    this.gatewayBaseUrl = gatewayBaseUrl;
    this.dexContractBasePath = dexContractBasePath;
    this.httpClient = httpClient;
  }
  /**
   * Gets pool data for a specific token pair and fee tier.
   */
  async getPoolData(token0, token1, fee) {
    validateFee(fee);
    const token0Class = parseTokenClassKey(token0);
    const token1Class = parseTokenClassKey(token1);
    const ordering = getTokenOrdering(token0Class, token1Class, false);
    const responseBody = await this.httpClient.sendPostRequest(this.gatewayBaseUrl, this.dexContractBasePath, "/GetPoolData", {
      token0: ordering.token0,
      token1: ordering.token1,
      fee
    });
    const rawData = responseBody.Data;
    return {
      bitmap: rawData.bitmap,
      fee: rawData.fee,
      feeGrowthGlobal0: BigNumber2(rawData.feeGrowthGlobal0),
      feeGrowthGlobal1: BigNumber2(rawData.feeGrowthGlobal1),
      grossPoolLiquidity: BigNumber2(rawData.grossPoolLiquidity),
      liquidity: BigNumber2(rawData.liquidity),
      maxLiquidityPerTick: BigNumber2(rawData.maxLiquidityPerTick),
      protocolFees: rawData.protocolFees,
      protocolFeesToken0: BigNumber2(rawData.protocolFeesToken0),
      protocolFeesToken1: BigNumber2(rawData.protocolFeesToken1),
      sqrtPrice: BigNumber2(rawData.sqrtPrice),
      tickSpacing: rawData.tickSpacing,
      token0: rawData.token0,
      token0ClassKey: rawData.token0ClassKey,
      token1: rawData.token1,
      token1ClassKey: rawData.token1ClassKey
    };
  }
  /**
   * Calculates the nearest valid tick value for a given price.
   */
  calculateTicksForPrice(price, tickSpacing) {
    validateNumericAmount(price, "price", true);
    validateTickSpacing(tickSpacing);
    const priceNumber = BigNumber2(price).toNumber();
    if (priceNumber === 0) {
      return -886800;
    }
    if (priceNumber === Infinity) {
      return 886800;
    }
    const uncoercedTicks = Math.round(Math.log(priceNumber) / Math.log(1.0001));
    const ticks = Math.floor(uncoercedTicks / tickSpacing) * tickSpacing;
    return Math.min(Math.max(ticks, -886800), 886800);
  }
  calculatePriceForTicks(tick) {
    if (tick === -886800) {
      return BigNumber2("0");
    } else if (tick === 886800) {
      return BigNumber2(Infinity);
    } else {
      const price = Math.pow(1.0001, tick);
      return BigNumber2(price);
    }
  }
  /**
   * Calculates the current spot price of a pool based on sqrt price.
   * Price is defined as the amount of outToken you would receive for 1 inToken.
   */
  calculateSpotPrice(inToken, outToken, poolSqrtPrice) {
    validateNumericAmount(poolSqrtPrice, "poolSqrtPrice");
    const ordering = getTokenOrdering(inToken, outToken, false);
    const poolPrice = BigNumber2(poolSqrtPrice).pow(2);
    if (ordering.zeroForOne) {
      return poolPrice;
    } else {
      return BigNumber2(1).div(poolPrice);
    }
  }
};

// src/classes/positions.ts
import BigNumber3 from "bignumber.js";
var Positions = class {
  constructor(gatewayBaseUrl, dexContractBasePath, bundlerService, poolService, httpClient, options) {
    this.gatewayBaseUrl = gatewayBaseUrl;
    this.dexContractBasePath = dexContractBasePath;
    this.options = options;
    this.httpClient = httpClient;
    this.bundlerService = bundlerService;
    this.poolService = poolService;
  }
  httpClient;
  bundlerService;
  poolService;
  /**
   * Get all liquidity positions for a specific wallet address.
   * @param ownerAddress - The wallet address to get positions for.
   * @param limit - Maximum number of positions to return.
   * @param bookmark - Pagination bookmark for retrieving additional results. If you call this function and it returns a bookmark that is not an empty string, you can pass that bookmark as this parameter in a subsequent call to fetch the next page.
   * @returns User positions and pagination bookmark
   * @example
   * ```typescript
   * const positions = await gSwap.positions.getUserPositions('eth|123...abc');
   * console.log(positions);
   * ```
   */
  async getUserPositions(ownerAddress, limit, bookmark) {
    const results = await this.sendUserPositionsRequest("/GetUserPositions", {
      user: ownerAddress,
      limit,
      bookmark
    });
    return {
      bookmark: results.nextBookMark,
      positions: results.positions
    };
  }
  /**
   * Gets detailed information about a specific liquidity position.
   * @param ownerAddress - The wallet address that owns the position.
   * @param position - Position parameters including tokens, fee, and tick range.
   * @param position.token0ClassKey - The first token in the position.
   * @param position.token1ClassKey - The second token in the position.
   * @param position.fee - The pool fee tier.
   * @param position.tickLower - The lower tick of the position range.
   * @param position.tickUpper - The upper tick of the position range.
   * @returns Detailed position information.
   * @example
   * ```typescript
   * const position = await gSwap.positions.getPosition('eth|123...abc', {
   *   token0ClassKey: 'GALA|Unit|none|none',
   *   token1ClassKey: 'GUSDC|Unit|none|none',
   *   fee: 500,
   *   tickLower: -6000,
   *   tickUpper: 6000
   * });
   * console.log('Position:', position);
   * ```
   */
  async getPosition(ownerAddress, position) {
    const result = await this.sendPositionRequest("/GetPositions", {
      owner: ownerAddress,
      token0: parseTokenClassKey(position.token0ClassKey),
      token1: parseTokenClassKey(position.token1ClassKey),
      fee: position.fee,
      tickLower: position.tickLower,
      tickUpper: position.tickUpper
    });
    return result;
  }
  /**
   * Estimates the token amounts that would be received from removing liquidity from a position.
   * @param args - Parameters for estimating liquidity removal.
   * @param args.ownerAddress - The wallet address that owns the position.
   * @param args.positionId - The position identifier.
   * @param args.token0 - The first token in the pair.
   * @param args.token1 - The second token in the pair.
   * @param args.fee - The pool fee tier.
   * @param args.tickLower - The lower tick of the position range.
   * @param args.tickUpper - The upper tick of the position range.
   * @param args.amount - The amount of liquidity to remove.
   * @returns Estimated token amounts that would be received.
   * @example
   * ```typescript
   * const estimation = await gSwap.positions.estimateRemoveLiquidity({
   *   ownerAddress: 'client|635f048ab243d7eb7f5ba044',
   *   positionId: '210f8e4dd1bbe1b4af4b977330ee7e4b68bc716f66e39c87a60fff0976ded3ea',
   *   token0: 'GALA|Unit|none|none',
   *   token1: 'GUSDT|Unit|none|none',
   *   fee: 3000,
   *   tickLower: -41100,
   *   tickUpper: -40080,
   *   amount: '1491.973332758921980256'
   * });
   * console.log('Estimated tokens:', estimation);
   * ```
   */
  async estimateRemoveLiquidity(args) {
    validateWalletAddress(args.ownerAddress);
    validateFee(args.fee);
    validateTickRange(args.tickLower, args.tickUpper);
    validateNumericAmount(args.amount, "amount");
    const token0TokenClassKey = parseTokenClassKey(args.token0);
    const token1TokenClassKey = parseTokenClassKey(args.token1);
    const ordering = getTokenOrdering(token0TokenClassKey, token1TokenClassKey, false);
    const responseBody = await this.httpClient.sendPostRequest(this.gatewayBaseUrl, this.dexContractBasePath, "/GetRemoveLiquidityEstimation", {
      tickLower: args.tickLower,
      tickUpper: args.tickUpper,
      amount: BigNumber3(args.amount).toFixed(),
      token0: ordering.token0,
      token1: ordering.token1,
      fee: args.fee,
      owner: args.ownerAddress,
      positionId: args.positionId
    });
    return {
      amount0: BigNumber3(responseBody.Data.amount0),
      amount1: BigNumber3(responseBody.Data.amount1)
    };
  }
  /**
   * Gets detailed information about a liquidity position by its ID.
   * @param ownerAddress - The wallet address that owns the position.
   * @param positionId - The unique identifier of the position.
   * @returns Detailed position information, or undefined if not found.
   * @example
   * ```typescript
   * const position = await gSwap.positions.getPositionById('eth|123...abc', 'position-uuid-123');
   * if (position) {
   *   console.log('Position found:', position);
   * } else {
   *   console.log('Position not found');
   * }
   * ```
   */
  async getPositionById(ownerAddress, positionId) {
    const userPositions = await this.getUserPositions(ownerAddress);
    const position = userPositions.positions.find((pos) => pos.positionId === positionId);
    if (!position) {
      return void 0;
    }
    return this.getPosition(ownerAddress, position);
  }
  /**
   * Creates a new position or adds liquidity to a position, using a specific tick range. Consider using `addLiquidityByPrice()` instead unless you want to use ticks directly.
   * @param args - Parameters for adding liquidity.
   * @param args.walletAddress - The wallet address adding liquidity.
   * @param args.positionId - The position identifier. If you're creating a new position, this should be an empty string.
   * @param args.token0 - The first token in the pair.
   * @param args.token1 - The second token in the pair.
   * @param args.fee - The pool fee tier.
   * @param args.tickLower - The lower tick of the position range.
   * @param args.tickUpper - The upper tick of the position range.
   * @param args.amount0Desired - Desired (also maximum) amount of token0 to add.
   * @param args.amount1Desired - Desired (also maximum) amount of token1 to add.
   * @param args.amount0Min - Minimum amount of token0 to add (slippage protection).
   * @param args.amount1Min - Minimum amount of token1 to add (slippage protection).
   * @returns Pending transaction.
   * @example
   * ```typescript
   * const result = await gSwap.positions.addLiquidityByTicks({
   *   walletAddress: 'eth|123...abc',
   *   positionId: '',
   *   token0: 'GALA|Unit|none|none',
   *   token1: 'GUSDC|Unit|none|none',
   *   fee: 500,
   *   tickSpacing: 10,
   *   tickLower: -6000,
   *   tickUpper: 6000,
   *   amount0Desired: '100',
   *   amount1Desired: '50',
   *   amount0Min: '95',
   *   amount1Min: '47.5'
   * });
   * console.log('Liquidity added:', result);
   * ```
   */
  async addLiquidityByTicks(args) {
    var _a;
    const walletAddress = args.walletAddress ?? ((_a = this.options) == null ? void 0 : _a.walletAddress);
    validateWalletAddress(walletAddress);
    validateFee(args.fee);
    validateTickRange(args.tickLower, args.tickUpper);
    validateNumericAmount(args.amount0Desired, "amount0Desired", true);
    validateNumericAmount(args.amount1Desired, "amount1Desired", true);
    validateNumericAmount(args.amount0Min, "amount0Min", true);
    validateNumericAmount(args.amount1Min, "amount1Min", true);
    const token0TokenClassKey = parseTokenClassKey(args.token0);
    const token1TokenClassKey = parseTokenClassKey(args.token1);
    const ordering = getTokenOrdering(
      token0TokenClassKey,
      token1TokenClassKey,
      true,
      [args.amount0Desired, args.amount0Min],
      [args.amount1Desired, args.amount1Min]
    );
    const toSign = {
      token0: ordering.token0,
      token1: ordering.token1,
      fee: args.fee,
      owner: args.walletAddress,
      tickLower: args.tickLower,
      tickUpper: args.tickUpper,
      amount0Desired: BigNumber3(ordering.token0Attributes[0]).toFixed(),
      amount1Desired: BigNumber3(ordering.token1Attributes[0]).toFixed(),
      amount0Min: BigNumber3(ordering.token0Attributes[1]).toFixed(),
      amount1Min: BigNumber3(ordering.token1Attributes[1]).toFixed(),
      positionId: args.positionId
    };
    const token0StringKey = stringifyTokenClassKey(ordering.token0, "$");
    const token1StringKey = stringifyTokenClassKey(ordering.token1, "$");
    const poolString = `$pool$${token0StringKey}$${token1StringKey}$${args.fee}`;
    const userPositionString = `$userPosition$${args.walletAddress}`;
    const tokenBalance0 = `$tokenBalance$${token0StringKey}$${args.walletAddress}`;
    const tokenBalance1 = `$tokenBalance$${token1StringKey}$${args.walletAddress}`;
    const tokenBalance0Pool = `$tokenBalance$${token0StringKey}$${poolString}`;
    const tokenBalance1Pool = `$tokenBalance$${token1StringKey}$${poolString}`;
    const stringsInstructions = [
      poolString,
      userPositionString,
      tokenBalance0,
      tokenBalance1,
      tokenBalance0Pool,
      tokenBalance1Pool
    ];
    return this.bundlerService.sendBundlerRequest("AddLiquidity", toSign, stringsInstructions);
  }
  /**
   * Creates a new position or adds liquidity to a position, using a specified price range. Note that this method automatically converts your minPrice and maxPrice to ticks, rounding down if necessary.
   * @param args - Parameters for adding liquidity.
   * @param args.walletAddress - The wallet address adding liquidity.
   * @param args.positionId - The position identifier. This should be an empty string if you are creating a new position.
   * @param args.token0 - The first token in the pair.
   * @param args.token1 - The second token in the pair.
   * @param args.fee - The pool fee tier.
   * @param args.tickSpacing - The tick spacing for the pool.
   * @param args.minPrice - The minimum price for the position range.
   * @param args.maxPrice - The maximum price for the position range.
   * @param args.amount0Desired - Desired (also maximum) amount of token0 to add.
   * @param args.amount1Desired - Desired (also maximum) amount of token1 to add.
   * @param args.amount0Min - Minimum amount of token0 to add (slippage protection).
   * @param args.amount1Min - Minimum amount of token1 to add (slippage protection).
   * @returns Pending transaction.
   * @example
   * ```typescript
   * const result = await gSwap.positions.addLiquidityByPrice({
   *   walletAddress: 'eth|123...abc',
   *   positionId: '',
   *   token0: 'GALA|Unit|none|none',
   *   token1: 'GUSDC|Unit|none|none',
   *   fee: 500,
   *   tickSpacing: 10,
   *   minPrice: '0.45',
   *   maxPrice: '0.55',
   *   amount0Desired: '100',
   *   amount1Desired: '50',
   *   amount0Min: '95',
   *   amount1Min: '47.5'
   * });
   * console.log('Liquidity added with price range:', result);
   * ```
   */
  async addLiquidityByPrice(args) {
    var _a, _b, _c, _d, _e;
    const walletAddress = args.walletAddress ?? ((_a = this.options) == null ? void 0 : _a.walletAddress);
    validateWalletAddress(walletAddress);
    validateFee(args.fee);
    validateTickSpacing(args.tickSpacing);
    validateNumericAmount(args.minPrice, "minPrice", true);
    validateNumericAmount(args.maxPrice, "maxPrice");
    validateNumericAmount(args.amount0Desired, "amount0Desired", true);
    validateNumericAmount(args.amount1Desired, "amount1Desired", true);
    validateNumericAmount(args.amount0Min, "amount0Min", true);
    validateNumericAmount(args.amount1Min, "amount1Min", true);
    if (BigNumber3(args.minPrice).isGreaterThan(BigNumber3(args.maxPrice))) {
      throw new Error("Invalid price range: minPrice must be less than or equal to maxPrice");
    }
    const token0TokenClassKey = parseTokenClassKey(args.token0);
    const token1TokenClassKey = parseTokenClassKey(args.token1);
    const ordering = getTokenOrdering(
      token0TokenClassKey,
      token1TokenClassKey,
      true,
      [args.amount0Desired, args.amount0Min],
      [args.amount1Desired, args.amount1Min]
    );
    const minPriceTicks = this.poolService.calculateTicksForPrice(args.minPrice, args.tickSpacing);
    const maxPriceTicks = this.poolService.calculateTicksForPrice(args.maxPrice, args.tickSpacing);
    const tickLower = ordering.zeroForOne ? minPriceTicks : maxPriceTicks * -1;
    const tickUpper = ordering.zeroForOne ? maxPriceTicks : minPriceTicks * -1;
    const toSign = {
      token0: ordering.token0,
      token1: ordering.token1,
      fee: args.fee,
      owner: args.walletAddress,
      tickLower,
      tickUpper,
      amount0Desired: (_b = ordering == null ? void 0 : ordering.token0Attributes) == null ? void 0 : _b[0],
      amount1Desired: (_c = ordering == null ? void 0 : ordering.token1Attributes) == null ? void 0 : _c[0],
      amount0Min: (_d = ordering == null ? void 0 : ordering.token0Attributes) == null ? void 0 : _d[1],
      amount1Min: (_e = ordering == null ? void 0 : ordering.token1Attributes) == null ? void 0 : _e[1],
      positionId: args.positionId
    };
    const token0StringKey = stringifyTokenClassKey(ordering.token0, "$");
    const token1StringKey = stringifyTokenClassKey(ordering.token1, "$");
    const poolString = `$pool$${token0StringKey}$${token1StringKey}$${args.fee}`;
    const userPositionString = `$userPosition$${args.walletAddress}`;
    const tokenBalance0 = `$tokenBalance$${token0StringKey}$${args.walletAddress}`;
    const tokenBalance1 = `$tokenBalance$${token1StringKey}$${args.walletAddress}`;
    const tokenBalance0Pool = `$tokenBalance$${token0StringKey}$${poolString}`;
    const tokenBalance1Pool = `$tokenBalance$${token1StringKey}$${poolString}`;
    const stringsInstructions = [
      poolString,
      userPositionString,
      tokenBalance0,
      tokenBalance1,
      tokenBalance0Pool,
      tokenBalance1Pool
    ];
    return this.bundlerService.sendBundlerRequest("AddLiquidity", toSign, stringsInstructions);
  }
  /**
   * Removes liquidity from a position.
   * @param args - Parameters for removing liquidity.
   * @param args.walletAddress - The wallet address removing liquidity.
   * @param args.positionId - The position identifier.
   * @param args.token0 - The first token in the pair.
   * @param args.token1 - The second token in the pair.
   * @param args.fee - The pool fee tier.
   * @param args.tickLower - The lower tick of the position range.
   * @param args.tickUpper - The upper tick of the position range.
   * @param args.amount - The amount of liquidity to remove.
   * @param args.amount0Min - Minimum amount of token0 to receive (slippage protection, optional).
   * @param args.amount1Min - Minimum amount of token1 to receive (slippage protection, optional).
   * @returns Pending transaction.
   * @example
   * ```typescript
   * // Remove 50% of liquidity from a position
   * const result = await gSwap.positions.removeLiquidity({
   *   walletAddress: 'eth|123...abc',
   *   positionId: 'position-123',
   *   token0: 'GALA|Unit|none|none',
   *   token1: 'GUSDC|Unit|none|none',
   *   fee: 500,
   *   tickLower: -6000,
   *   tickUpper: 6000,
   *   amount: '50000000000000000000', // 50% of position liquidity
   *   amount0Min: '45',
   *   amount1Min: '22'
   * });
   * console.log('Liquidity removed:', result);
   * ```
   */
  async removeLiquidity(args) {
    var _a, _b, _c;
    const walletAddress = args.walletAddress ?? ((_a = this.options) == null ? void 0 : _a.walletAddress);
    validateWalletAddress(walletAddress);
    validateFee(args.fee);
    validateTickRange(args.tickLower, args.tickUpper);
    validateNumericAmount(args.amount, "amount");
    if (args.amount0Min !== void 0) {
      validateNumericAmount(args.amount0Min, "amount0Min", true);
    }
    if (args.amount1Min !== void 0) {
      validateNumericAmount(args.amount1Min, "amount1Min", true);
    }
    const token0TokenClassKey = parseTokenClassKey(args.token0);
    const token1TokenClassKey = parseTokenClassKey(args.token1);
    const ordering = getTokenOrdering(
      token0TokenClassKey,
      token1TokenClassKey,
      true,
      [args.amount0Min ?? 0],
      [args.amount1Min ?? 0]
    );
    const toSign = {
      token0: ordering.token0,
      token1: ordering.token1,
      fee: args.fee,
      tickLower: args.tickLower,
      tickUpper: args.tickUpper,
      amount: BigNumber3(args.amount).toFixed(),
      amount0Min: ((_b = ordering == null ? void 0 : ordering.token0Attributes) == null ? void 0 : _b[0]) || "0",
      amount1Min: ((_c = ordering == null ? void 0 : ordering.token1Attributes) == null ? void 0 : _c[0]) || "0",
      positionId: args.positionId
    };
    const token0StringKey = stringifyTokenClassKey(ordering.token0, "$");
    const token1StringKey = stringifyTokenClassKey(ordering.token1, "$");
    const poolString = `$pool$${token0StringKey}$${token1StringKey}$${args.fee}`;
    const userPositionString = `$userPosition$${args.walletAddress}`;
    const tokenBalance0 = `$tokenBalance$${token0StringKey}$${args.walletAddress}`;
    const tokenBalance1 = `$tokenBalance$${token1StringKey}$${args.walletAddress}`;
    const tokenBalance0Pool = `$tokenBalance$${token0StringKey}$${poolString}`;
    const tokenBalance1Pool = `$tokenBalance$${token1StringKey}$${poolString}`;
    const stringsInstructions = [
      poolString,
      userPositionString,
      tokenBalance0,
      tokenBalance1,
      tokenBalance0Pool,
      tokenBalance1Pool
    ];
    return this.bundlerService.sendBundlerRequest("RemoveLiquidity", toSign, stringsInstructions);
  }
  /**
   * Collects accumulated fees from a liquidity position.
   * @param args - Parameters for collecting fees.
   * @param args.walletAddress - The wallet address collecting fees.
   * @param args.positionId - The position identifier.
   * @param args.token0 - The first token in the pair.
   * @param args.token1 - The second token in the pair.
   * @param args.fee - The pool fee tier.
   * @param args.tickLower - The lower tick of the position range.
   * @param args.tickUpper - The upper tick of the position range.
   * @param args.amount0Requested - Desired amount of token0 fees to collect.
   * @param args.amount1Requested - Desired amount of token1 fees to collect.
   * @returns Pending transaction.
   * @example
   * ```typescript
   * // Collect all accumulated fees from a position
   * const result = await gSwap.positions.collectPositionFees({
   *   walletAddress: 'eth|123...abc',
   *   positionId: 'position-123',
   *   token0: 'GALA|Unit|none|none',
   *   token1: 'GUSDC|Unit|none|none',
   *   fee: 500,
   *   tickLower: -6000,
   *   tickUpper: 6000,
   *   amount0Requested: '1000000000000000000', // Max fees available
   *   amount1Requested: '500000000' // Max fees available
   * });
   * console.log('Fees collected:', result);
   * ```
   */
  async collectPositionFees(args) {
    var _a;
    const walletAddress = args.walletAddress ?? ((_a = this.options) == null ? void 0 : _a.walletAddress);
    validateWalletAddress(walletAddress);
    validateFee(args.fee);
    validateTickRange(args.tickLower, args.tickUpper);
    validateNumericAmount(args.amount0Requested, "amount0Requested", true);
    validateNumericAmount(args.amount1Requested, "amount1Requested", true);
    const token0TokenClassKey = parseTokenClassKey(args.token0);
    const token1TokenClassKey = parseTokenClassKey(args.token1);
    const ordering = getTokenOrdering(
      token0TokenClassKey,
      token1TokenClassKey,
      true,
      [args.amount0Requested],
      [args.amount1Requested]
    );
    const toSign = {
      token0: ordering.token0,
      token1: ordering.token1,
      fee: args.fee,
      amount0Requested: BigNumber3(ordering.token0Attributes[0]).toFixed(),
      amount1Requested: BigNumber3(ordering.token1Attributes[0]).toFixed(),
      tickLower: args.tickLower,
      tickUpper: args.tickUpper,
      positionId: args.positionId
    };
    const token0StringKey = stringifyTokenClassKey(ordering.token0, "$");
    const token1StringKey = stringifyTokenClassKey(ordering.token1, "$");
    const poolString = `$pool$${token0StringKey}$${token1StringKey}$${args.fee}`;
    const userPositionString = `$userPosition$${args.walletAddress}`;
    const tokenBalance0 = `$tokenBalance$${token0StringKey}$${args.walletAddress}`;
    const tokenBalance1 = `$tokenBalance$${token1StringKey}$${args.walletAddress}`;
    const tokenBalance0Pool = `$tokenBalance$${token0StringKey}$${poolString}`;
    const tokenBalance1Pool = `$tokenBalance$${token1StringKey}$${poolString}`;
    const stringsInstructions = [
      poolString,
      userPositionString,
      tokenBalance0,
      tokenBalance1,
      tokenBalance0Pool,
      tokenBalance1Pool
    ];
    return this.bundlerService.sendBundlerRequest(
      "CollectPositionFees",
      toSign,
      stringsInstructions
    );
  }
  calculateOptimalPositionSize(tokenAmount, spotPrice, lowerPrice, upperPrice, tokenDecimals, otherTokenDecimals) {
    validateNumericAmount(tokenAmount, "tokenAmount");
    validatePriceValues(spotPrice, lowerPrice, upperPrice);
    validateTokenDecimals(tokenDecimals, "tokenDecimals");
    validateTokenDecimals(otherTokenDecimals, "otherTokenDecimals");
    const bnTokenAmount = BigNumber3(tokenAmount);
    const bnSpotPrice = BigNumber3(spotPrice);
    const bnLowerPrice = BigNumber3(lowerPrice);
    let bnUpperPrice = BigNumber3(upperPrice);
    bnUpperPrice = bnUpperPrice.isFinite() ? bnUpperPrice : BigNumber3(1e18);
    const liquidityAmount = bnTokenAmount.times(10 ** (tokenDecimals - otherTokenDecimals)).times(bnSpotPrice.sqrt()).times(bnUpperPrice.sqrt()).div(bnUpperPrice.sqrt().minus(bnSpotPrice.sqrt()));
    const yAmount = BigNumber3(liquidityAmount).times(bnSpotPrice.sqrt().minus(bnLowerPrice.sqrt()));
    const untruncated = yAmount.div(BigNumber3(10).pow(tokenDecimals - otherTokenDecimals));
    return BigNumber3.max(
      BigNumber3(untruncated.toFixed(otherTokenDecimals, BigNumber3.ROUND_DOWN)),
      0
    );
  }
  async sendUserPositionsRequest(endpoint, body) {
    const responseBody = await this.httpClient.sendPostRequest(this.gatewayBaseUrl, this.dexContractBasePath, endpoint, body);
    return {
      nextBookMark: responseBody.Data.nextBookMark,
      positions: responseBody.Data.positions.map((position) => ({
        ...position,
        liquidity: BigNumber3(position.liquidity)
      }))
    };
  }
  async sendPositionRequest(endpoint, body) {
    const responseBody = await this.httpClient.sendPostRequest(this.gatewayBaseUrl, this.dexContractBasePath, endpoint, body);
    return {
      ...responseBody.Data,
      feeGrowthInside0Last: BigNumber3(responseBody.Data.feeGrowthInside0Last),
      feeGrowthInside1Last: BigNumber3(responseBody.Data.feeGrowthInside1Last),
      liquidity: BigNumber3(responseBody.Data.liquidity),
      tokensOwed0: BigNumber3(responseBody.Data.tokensOwed0),
      tokensOwed1: BigNumber3(responseBody.Data.tokensOwed1)
    };
  }
};

// src/classes/quoting.ts
import BigNumber4 from "bignumber.js";

// src/types/fees.ts
var FEE_TIER = /* @__PURE__ */ ((FEE_TIER2) => {
  FEE_TIER2[FEE_TIER2["PERCENT_00_05"] = 500] = "PERCENT_00_05";
  FEE_TIER2[FEE_TIER2["PERCENT_00_30"] = 3e3] = "PERCENT_00_30";
  FEE_TIER2[FEE_TIER2["PERCENT_01_00"] = 1e4] = "PERCENT_01_00";
  return FEE_TIER2;
})(FEE_TIER || {});

// src/classes/quoting.ts
var Quoting = class {
  constructor(gatewayBaseUrl, dexContractBasePath, httpClient) {
    this.gatewayBaseUrl = gatewayBaseUrl;
    this.dexContractBasePath = dexContractBasePath;
    this.httpClient = httpClient ?? new HttpClient();
  }
  httpClient;
  /**
   * Gets a quote for an exact amount of token being sold.
   * @param tokenIn - The input token to sell.
   * @param tokenOut - The output token to buy.
   * @param amountIn - The exact amount of input tokens you want to sell.
   * @param fee - The pool fee tier. If not specified, will check all available fee tiers and return the best quote.
   * @returns The expected number of tokens you will receive (buy) when/if you execute the swap.
   */
  async quoteExactInput(tokenIn, tokenOut, amountIn, fee) {
    validateNumericAmount(amountIn, "amountIn");
    if (fee !== void 0) {
      const result = await this.getSingleQuoteExactInput(tokenIn, tokenOut, fee, amountIn);
      return result;
    }
    const allFees = [500 /* PERCENT_00_05 */, 3e3 /* PERCENT_00_30 */, 1e4 /* PERCENT_01_00 */];
    const quotePromises = allFees.map(async (feeTier) => {
      try {
        return await this.getSingleQuoteExactInput(tokenIn, tokenOut, feeTier, amountIn);
      } catch (err) {
        if (err instanceof GSwapSDKError && (err.code === "CONFLICT" || err.code === "OBJECT_NOT_FOUND")) {
          return void 0;
        }
        throw err;
      }
    });
    const results = await Promise.all(quotePromises);
    const quotes = results.filter((quote) => quote !== void 0);
    if (quotes.length === 0) {
      throw GSwapSDKError.noPoolAvailableError(tokenIn, tokenOut);
    }
    return quotes.reduce(
      (best, current) => current.outTokenAmount.isGreaterThan(best.outTokenAmount) ? current : best
    );
  }
  /**
   * Gets a quote for an exact amount of tokens being bought.
   * @param tokenIn - The input token sell.
   * @param tokenOut - The output token to buy.
   * @param amountOut - The exact amount of output tokens you want to buy.
   * @param fee - The pool fee tier. If not specified, will check all available fee tiers and return the best quote.
   * @returns The expected number of tokens you will need to sell (input) to receive the specified amount of output tokens.
   */
  async quoteExactOutput(tokenIn, tokenOut, amountOut, fee) {
    validateNumericAmount(amountOut, "amountOut");
    if (fee !== void 0) {
      const result = await this.getSingleQuoteExactOutput(tokenIn, tokenOut, amountOut, fee);
      return result;
    }
    const allFees = [500 /* PERCENT_00_05 */, 3e3 /* PERCENT_00_30 */, 1e4 /* PERCENT_01_00 */];
    const quotePromises = allFees.map(async (feeTier) => {
      try {
        return await this.getSingleQuoteExactOutput(tokenIn, tokenOut, amountOut, feeTier);
      } catch (err) {
        if (err instanceof GSwapSDKError && (err.code === "CONFLICT" || err.code === "OBJECT_NOT_FOUND")) {
          return void 0;
        }
        throw err;
      }
    });
    const results = await Promise.all(quotePromises);
    const quotes = results.filter((quote) => quote !== void 0);
    if (quotes.length === 0) {
      throw GSwapSDKError.noPoolAvailableError(tokenIn, tokenOut);
    }
    return quotes.reduce(
      (best, current) => current.inTokenAmount.isLessThan(best.inTokenAmount) ? current : best
    );
  }
  async getSingleQuote(tokenIn, tokenOut, fee, amount, isExactInput) {
    const tokenInClass = parseTokenClassKey(tokenIn);
    const tokenOutClass = parseTokenClassKey(tokenOut);
    const ordering = getTokenOrdering(tokenInClass, tokenOutClass, false);
    const formattedAmount = isExactInput ? BigNumber4(amount).toFixed() : BigNumber4(amount).multipliedBy(-1).toFixed();
    const response = await this.sendQuoteRequest("/QuoteExactAmount", {
      ...ordering,
      fee,
      amount: formattedAmount
    });
    const tokenInAmount = ordering.zeroForOne ? response.amount0 : response.amount1;
    const tokenOutAmount = ordering.zeroForOne ? response.amount1 : response.amount0;
    let currentPrice = response.currentSqrtPrice.pow(2);
    let newPrice = response.newSqrtPrice.pow(2);
    if (!ordering.zeroForOne) {
      currentPrice = BigNumber4(1).dividedBy(currentPrice);
      newPrice = BigNumber4(1).dividedBy(newPrice);
    }
    const priceImpact = newPrice.minus(currentPrice).dividedBy(currentPrice);
    return {
      amount0: response.amount0,
      amount1: response.amount1,
      currentPoolSqrtPrice: response.currentSqrtPrice,
      newPoolSqrtPrice: response.newSqrtPrice,
      currentPrice,
      newPrice,
      inTokenAmount: tokenInAmount.abs(),
      outTokenAmount: tokenOutAmount.abs(),
      priceImpact,
      feeTier: fee
    };
  }
  async getSingleQuoteExactInput(tokenIn, tokenOut, fee, amountIn) {
    return this.getSingleQuote(tokenIn, tokenOut, fee, amountIn, true);
  }
  async getSingleQuoteExactOutput(tokenIn, tokenOut, amountOut, fee) {
    return this.getSingleQuote(tokenIn, tokenOut, fee, amountOut, false);
  }
  async sendQuoteRequest(endpoint, body) {
    const response = await this.httpClient.sendPostRequest(
      this.gatewayBaseUrl,
      this.dexContractBasePath,
      endpoint,
      body
    );
    const responseBody = response;
    return {
      amount0: BigNumber4(responseBody.Data.amount0),
      amount1: BigNumber4(responseBody.Data.amount1),
      currentSqrtPrice: BigNumber4(responseBody.Data.currentSqrtPrice),
      newSqrtPrice: BigNumber4(responseBody.Data.newSqrtPrice)
    };
  }
};

// src/classes/swaps.ts
import BigNumber5 from "bignumber.js";
var MIN_SQRT_PRICE_LIMIT = "0.000000000000000000094212147";
var MAX_SQRT_PRICE_LIMIT = "18446050999999999999";
var Swaps = class {
  constructor(bundlerService, options) {
    this.bundlerService = bundlerService;
    this.options = options;
  }
  /**
   * Executes a token swap transaction.
   * @param walletAddress - The wallet address executing the swap.
   * @param tokenIn - The input token to sell.
   * @param tokenOut - The output token to buy.
   * @param fee - The pool fee tier.
   * @param amount - Swap parameters specifying either exact input or exact output.
   * @param amount.exactIn - For exact input swaps, the exact amount of input tokens to sell.
   * @param amount.amountOutMinimum - For exact input swaps, the minimum amount of output tokens to buy (slippage protection).
   * @param amount.exactOut - For exact output swaps, the exact amount of output tokens to buy.
   * @param amount.amountInMaximum - For exact output swaps, the maximum amount of input tokens to sell (slippage protection).
   * @returns Pending transaction.
   * @example
   * ```typescript
   * // Exact input swap: sell 100 GALA for USDC
   * const result = await swapsService.swap(
   *   'GALA|Unit|none|none',
   *   'GUSDC|Unit|none|none',
   *   500,
   *   { exactIn: '100', amountOutMinimum: '45' },
   *   'eth|123...abc', // your wallet address
   * );
   * console.log('Swap successful:', result);
   * ```
   */
  async swap(tokenIn, tokenOut, fee, amount, walletAddress) {
    var _a, _b;
    walletAddress = walletAddress ?? ((_a = this.options) == null ? void 0 : _a.walletAddress);
    validateWalletAddress(walletAddress);
    validateFee(fee);
    if ("exactIn" in amount) {
      validateNumericAmount(amount.exactIn, "exactIn");
      if (amount.amountOutMinimum !== void 0) {
        validateNumericAmount(amount.amountOutMinimum, "amountOutMinimum", true);
      }
    } else {
      validateNumericAmount(amount.exactOut, "exactOut");
      if (amount.amountInMaximum !== void 0) {
        validateNumericAmount(amount.amountInMaximum, "amountInMaximum");
      }
    }
    const ordering = getTokenOrdering(tokenIn, tokenOut, false);
    const zeroForOne = stringifyTokenClassKey(tokenIn) === stringifyTokenClassKey(ordering.token0);
    const rawAmount = "exactIn" in amount ? BigNumber5(amount.exactIn).toFixed() : BigNumber5(amount.exactOut).multipliedBy(-1).toFixed();
    const rawAmountOutMinimum = "exactIn" in amount ? ((_b = amount.amountOutMinimum) == null ? void 0 : _b.toString()) ? BigNumber5(amount.amountOutMinimum).multipliedBy(-1).toFixed() : void 0 : BigNumber5(amount.exactOut ?? 0).multipliedBy(-1).toFixed();
    const rawAmountInMaximum = "exactIn" in amount ? BigNumber5(amount.exactIn).toFixed() : amount.amountInMaximum ? BigNumber5(amount.amountInMaximum).toFixed() : void 0;
    const toSign = {
      token0: parseTokenClassKey(ordering.token0),
      token1: parseTokenClassKey(ordering.token1),
      fee,
      amount: rawAmount,
      zeroForOne,
      sqrtPriceLimit: ordering.zeroForOne ? MIN_SQRT_PRICE_LIMIT : MAX_SQRT_PRICE_LIMIT,
      recipient: walletAddress,
      amountOutMinimum: rawAmountOutMinimum,
      amountInMaximum: rawAmountInMaximum
    };
    const token0StringKey = stringifyTokenClassKey(ordering.token0, "$");
    const token1StringKey = stringifyTokenClassKey(ordering.token1, "$");
    const poolString = `$pool$${token0StringKey}$${token1StringKey}$${fee}`;
    const tokenBalance0 = `$tokenBalance$${token0StringKey}$${walletAddress}`;
    const tokenBalance1 = `$tokenBalance$${token1StringKey}$${walletAddress}`;
    const tokenBalance0Pool = `$tokenBalance$${token0StringKey}$${poolString}`;
    const tokenBalance1Pool = `$tokenBalance$${token1StringKey}$${poolString}`;
    const stringsInstructions = [
      poolString,
      tokenBalance0,
      tokenBalance1,
      tokenBalance0Pool,
      tokenBalance1Pool
    ];
    return this.bundlerService.sendBundlerRequest("Swap", toSign, stringsInstructions);
  }
};

// src/classes/gswap.ts
var GSwap = class {
  gatewayBaseUrl;
  dexContractBasePath;
  tokenContractBasePath;
  bundlerBaseUrl;
  bundlingAPIBasePath;
  dexBackendBaseUrl;
  transactionWaitTimeoutMs;
  signer;
  /**
   * Quoting functionality for price discovery and trade estimation.
   * Use this to get quotes for token swaps without executing transactions.
   *
   * @example
   * ```typescript
   * // Get the best quote across all fee tiers
   * const quote = await gSwap.quoting.quoteExactInput(tokenA, tokenB, amount);
   * ```
   */
  quoting;
  /**
   * Position management operations for liquidity positions.
   * Use this to manage liquidity positions including creation, modification, and fee collection.
   *
   * @example
   * ```typescript
   * // Get all user positions
   * const positions = await gSwap.positions.getUserPositions('eth|123...abc');
   *
   * // Add liquidity to a position using price range
   * const result = await gSwap.positions.addLiquidityByPrice({
   *   walletAddress: 'eth|123...abc',
   *   positionId: '',
   *   token0: 'GALA|Unit|none|none',
   *   token1: 'GUSDC|Unit|none|none',
   *   fee: 500,
   *   tickSpacing: 10,
   *   minPrice: '0.45',
   *   maxPrice: '0.55',
   *   amount0Desired: '100',
   *   amount1Desired: '50',
   *   amount0Min: '95',
   *   amount1Min: '47.5'
   * });
   * ```
   */
  positions;
  /**
   * Token swap operations for trading tokens.
   * Use this to execute token swaps on the DEX.
   *
   * @example
   * ```typescript
   * // Execute an exact input swap: sell 100 GALA for USDC
   * const result = await gSwap.swaps.swap(
   *   'GALA|Unit|none|none',
   *   'GUSDC|Unit|none|none',
   *   500,
   *   { exactIn: '100', amountOutMinimum: '45' },
   *   'eth|123...abc', // your wallet address
   * );
   * ```
   */
  swaps;
  /**
   * User asset management operations.
   * Use this to retrieve user token balances and asset information.
   *
   * @example
   * ```typescript
   * // Get user assets with pagination
   * const assets = await gSwap.assets.getUserAssets('eth|123...abc', 1, 20);
   * console.log(`User has ${assets.count} different tokens`);
   * ```
   */
  assets;
  /**
   * Event management operations for real-time socket connections.
   * Use this to manage event streaming and transaction status updates.
   *
   * @example
   * ```typescript
   * // Connect to event socket for transaction updates
   * await GSwap.events.connectEventSocket();
   *
   * // Check if socket is connected
   * const isConnected = GSwap.events.eventSocketConnected();
   * ```
   */
  static events = Events.instance;
  httpClient;
  httpRequestor;
  bundler;
  pools;
  /**
   * Creates a new SDK instance.
   * @param options - Customization options.
   * @param options.signer - The signer to use for authenticated operations. Required if you use any functionality that creates transactions (such as swapping). Not required for readonly operations.
   * @param options.gatewayBaseUrl - Base URL for the GalaChain Gateway API.
   * @param options.dexContractBasePath - Base path for DEX contract API endpoints, within the GalaChain Gateway API.
   * @param options.tokenContractBasePath - Base path for token contract API endpoints, within the GalaChain Gateway API.
   * @param options.bundlerBaseUrl - Base URL for the DEX transaction bundling API.
   * @param options.bundlingAPIBasePath - Base path for transaction bundling API endpoints.
   * @param options.dexBackendBaseUrl - Base URL for the DEX backend API (for user assets and other data).
   * @param options.httpRequestor - Custom HTTP requestor to use for API calls. Defaults to the global `fetch` function.
   * @param options.transactionWaitTimeoutMs - Timeout in milliseconds for waiting for transactions to complete. Defaults to 300,000 milliseconds (five minutes).
   * @param options.walletAddress - Optional default wallet address for operations that require a wallet address (e.x. swapping). If not provided, you must specify the wallet address in each method call.
   */
  constructor(options) {
    var _a;
    this.gatewayBaseUrl = ((_a = options == null ? void 0 : options.gatewayBaseUrl) == null ? void 0 : _a.replace(/\/$/, "")) ?? "https://gateway-mainnet.galachain.com";
    this.dexContractBasePath = (options == null ? void 0 : options.dexContractBasePath) ?? "/api/asset/dexv3-contract";
    this.tokenContractBasePath = (options == null ? void 0 : options.tokenContractBasePath) ?? "/api/asset/token-contract";
    this.bundlerBaseUrl = (options == null ? void 0 : options.bundlerBaseUrl) ?? "https://bundle-backend-prod1.defi.gala.com";
    this.bundlingAPIBasePath = (options == null ? void 0 : options.bundlingAPIBasePath) ?? "/bundle";
    this.dexBackendBaseUrl = (options == null ? void 0 : options.dexBackendBaseUrl) ?? "https://dex-backend-prod1.defi.gala.com";
    this.signer = options == null ? void 0 : options.signer;
    this.transactionWaitTimeoutMs = (options == null ? void 0 : options.transactionWaitTimeoutMs) ?? 3e5;
    this.httpRequestor = (options == null ? void 0 : options.httpRequestor) ?? fetch.bind(globalThis);
    this.httpClient = new HttpClient(this.httpRequestor);
    this.bundler = new Bundler(
      this.bundlerBaseUrl,
      this.bundlingAPIBasePath,
      this.transactionWaitTimeoutMs,
      this.signer,
      this.httpClient
    );
    this.pools = new Pools(this.gatewayBaseUrl, this.dexContractBasePath, this.httpClient);
    this.quoting = new Quoting(this.gatewayBaseUrl, this.dexContractBasePath, this.httpClient);
    this.positions = new Positions(
      this.gatewayBaseUrl,
      this.dexContractBasePath,
      this.bundler,
      this.pools,
      this.httpClient,
      { walletAddress: options == null ? void 0 : options.walletAddress }
    );
    this.swaps = new Swaps(this.bundler, { walletAddress: options == null ? void 0 : options.walletAddress });
    this.assets = new Assets(this.dexBackendBaseUrl, this.httpClient);
  }
};

// src/classes/signers.ts
import { signatures } from "@gala-chain/api";
import { calculatePersonalSignPrefix } from "@gala-chain/connect";
var PrivateKeySigner = class {
  keyBuffer;
  constructor(privateKey) {
    this.keyBuffer = signatures.normalizePrivateKey(privateKey);
  }
  async signObject(_methodName, obj) {
    const signature = signatures.getSignature(obj, this.keyBuffer);
    return { ...obj, signature };
  }
};
var GalaWalletSigner = class _GalaWalletSigner {
  constructor(walletAddress) {
    this.walletAddress = walletAddress;
  }
  async signObject(methodName, obj) {
    const globalGala = global.gala;
    if (!globalGala) {
      throw new GSwapSDKError(
        "Gala wallet is not available. Please ensure the Gala wallet is connected.",
        "GALA_WALLET_NOT_AVAILABLE"
      );
    }
    const domain = { name: "ethereum", chainId: 1 };
    const types = _GalaWalletSigner.generateEIP712Types(methodName, obj);
    const signRequest = {
      domain,
      types,
      Primary_type: methodName,
      message: {
        ...obj,
        prefix: calculatePersonalSignPrefix(obj)
      }
    };
    await globalGala.setAddress(this.walletAddress);
    const signature = await globalGala.request({
      method: "eth_signTypedData",
      params: [JSON.stringify(signRequest), this.walletAddress]
    });
    return { ...obj, domain, types, signature };
  }
  static generateEIP712Types(typeName, params) {
    const types = {};
    types[typeName] = [];
    function addField(name, fieldValue, parentTypeName, onlyGetType = false) {
      if (fieldValue === void 0) {
      } else if (Array.isArray(fieldValue)) {
        const type = addField(name, fieldValue[0], parentTypeName, true);
        if (!onlyGetType) types[parentTypeName].push({ name, type: (type ?? name) + "[]" });
      } else if (typeof fieldValue === "object" && fieldValue !== null) {
        if (types[name]) {
          throw new GSwapSDKError(
            "Name collisions not yet supported in EIP712 type generation",
            "EIP712_NAME_COLLISION",
            { name }
          );
        }
        types[name] = [];
        Object.entries(fieldValue).forEach(([key, value]) => {
          addField(key, value, name);
        });
        if (!onlyGetType) types[parentTypeName].push({ name, type: name });
      } else {
        let eipType;
        switch (typeof fieldValue) {
          case "string":
            eipType = "string";
            break;
          case "number":
            eipType = "int256";
            break;
          case "boolean":
            eipType = "bool";
            break;
          default:
            throw new GSwapSDKError(
              `Unsupported type for EIP712 signing: ${typeof fieldValue}`,
              "EIP712_UNSUPPORTED_TYPE",
              { type: typeof fieldValue, value: fieldValue }
            );
        }
        if (onlyGetType) {
          return eipType;
        } else {
          types[parentTypeName].push({ name, type: eipType });
        }
      }
    }
    Object.entries(params).forEach(([key, value]) => {
      addField(key, value, typeName);
    });
    return types;
  }
};
export {
  Assets,
  Bundler,
  EventSocketClient,
  Events,
  FEE_TIER,
  GSwap,
  GSwapSDKError,
  GalaWalletSigner,
  PendingTransaction,
  Pools,
  Positions,
  PrivateKeySigner,
  Quoting,
  Swaps,
  TradeEventEmitter,
  compareTokens,
  getTokenOrdering,
  parseTokenClassKey,
  stringifyTokenClassKey,
  validateFee,
  validateNumericAmount,
  validatePriceValues,
  validateTickRange,
  validateTickSpacing,
  validateTokenDecimals,
  validateWalletAddress
};
//# sourceMappingURL=index.mjs.map