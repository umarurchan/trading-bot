"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ExpiredOfferError = exports.OfferUnavailableError = exports.UserMustBeRegistrarError = exports.ExclusiveRegistrarBorrowersError = exports.MissingInstanceBalanceError = exports.MultipleTokenBalancesError = exports.OfferBorrowerMismatchError = exports.InvalidTokenKeyError = exports.OfferLoanFungibleTokenNotImplementedError = exports.OfferLoanOwnerCallerMismatchError = exports.MissingLoanError = exports.LoanCloseForbiddenUserError = exports.LoanAlreadyClosedError = exports.InvalidClosingStatusError = void 0;
/*
 * Copyright (c) Gala Games Inc. All rights reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const utils_1 = require("../utils");
class InvalidClosingStatusError extends utils_1.ForbiddenError {
    constructor(closingStatus) {
        super(`CloseLoan() requires a valid closing status: Fulfilled or Cancelled. Received: ${closingStatus}`, {
            closingStatus
        });
    }
}
exports.InvalidClosingStatusError = InvalidClosingStatusError;
class LoanAlreadyClosedError extends utils_1.ConflictError {
    constructor(loanKey, status) {
        super(`loan with id ${loanKey} has been ${status} and its status can no longer be changed.`, {
            loanKey,
            status
        });
    }
}
exports.LoanAlreadyClosedError = LoanAlreadyClosedError;
class LoanCloseForbiddenUserError extends utils_1.ForbiddenError {
    constructor(callingUser, loanKey, owner, registrar) {
        super(`User ${callingUser} attempted to close Loan ${loanKey}, but does not match the ` +
            `loan owner (${owner}) nor the loan registrar (${registrar}).`, {
            callingUser,
            loanKey,
            owner,
            registrar
        });
    }
}
exports.LoanCloseForbiddenUserError = LoanCloseForbiddenUserError;
class MissingLoanError extends utils_1.NotFoundError {
    constructor(user, loanKey) {
        super(`Error finding loan (${loanKey}) on chain for user ${user}`, { user, loanKey });
    }
}
exports.MissingLoanError = MissingLoanError;
class OfferLoanOwnerCallerMismatchError extends utils_1.ForbiddenError {
    constructor(callingUser, owner) {
        super(`OfferLoan: Calling user (${callingUser}) does not match owner id provided in dto (${owner})`, {
            callingUser,
            owner
        });
    }
}
exports.OfferLoanOwnerCallerMismatchError = OfferLoanOwnerCallerMismatchError;
class OfferLoanFungibleTokenNotImplementedError extends utils_1.NotImplementedError {
    constructor(tokenQueryKey) {
        super(`OfferLoan currently supports Non-Fungible tokens only. Received fungible token instance: ` +
            `${tokenQueryKey}`, { tokenQueryKey });
    }
}
exports.OfferLoanFungibleTokenNotImplementedError = OfferLoanFungibleTokenNotImplementedError;
class InvalidTokenKeyError extends utils_1.ValidationFailedError {
    constructor(tokenKey, borrower) {
        super(`AcceptLoanOffer: failed to verify tokenKey for LoanOffer: ${tokenKey}, borrower: ${borrower}`, {
            tokenKey,
            borrower
        });
    }
}
exports.InvalidTokenKeyError = InvalidTokenKeyError;
class OfferBorrowerMismatchError extends utils_1.ValidationFailedError {
    constructor(borrower, offerBorrower, tokenKey) {
        super(`AcceptLoanOffer: requested borrower (${borrower}) does not match offer borrower (${offerBorrower})`, {
            borrower,
            offerBorrower,
            tokenKey
        });
    }
}
exports.OfferBorrowerMismatchError = OfferBorrowerMismatchError;
class MultipleTokenBalancesError extends utils_1.ForbiddenError {
    constructor(owner, completeKey) {
        super(`OfferLoan error: Complete query key for single instance provided, ` +
            `but multiple token balances received. owner: ${owner}, key: ${completeKey}`, {
            owner,
            completeKey
        });
    }
}
exports.MultipleTokenBalancesError = MultipleTokenBalancesError;
class MissingInstanceBalanceError extends utils_1.NotFoundError {
    constructor(owner, completeKey) {
        super(`OfferLoan error: Query key for single instace provided, ` +
            `but instance is not present in owner's balance. owner: ${owner}, key: ${completeKey}`, {
            owner,
            completeKey
        });
    }
}
exports.MissingInstanceBalanceError = MissingInstanceBalanceError;
class ExclusiveRegistrarBorrowersError extends utils_1.ConflictError {
    constructor(registrar, borrowers) {
        super(`OfferLoan called with both registrar ${registrar} and borrowers array defined. ` +
            `Only one may be defined. Borrowers: ${borrowers.join(", ")}`, {
            registrar,
            borrowers
        });
    }
}
exports.ExclusiveRegistrarBorrowersError = ExclusiveRegistrarBorrowersError;
class UserMustBeRegistrarError extends utils_1.ForbiddenError {
    constructor(registrar, callingUser, tokenKey, borrower) {
        super(`AcceptLoanOffer: Offer mediated by a registrar, callingUser not authorized. ` +
            `LoanOffer.registrar: ${registrar}, caller: ${callingUser}, ` +
            `LoanOffer: ${tokenKey}, borrower: ${borrower}`, {
            registrar,
            callingUser,
            tokenKey,
            borrower
        });
    }
}
exports.UserMustBeRegistrarError = UserMustBeRegistrarError;
class OfferUnavailableError extends utils_1.ForbiddenError {
    constructor(status, tokenKey, borrower) {
        super(`AcceptLoanOffer: Offer is no longer available. ` +
            `LoanOffer.status: ${status}, ` +
            `LoanOffer: ${tokenKey}, borrower: ${borrower}`, {
            status,
            tokenKey,
            borrower
        });
    }
}
exports.OfferUnavailableError = OfferUnavailableError;
// TODO: Implement 410 Gone error in galachain-common for this:
class ExpiredOfferError extends utils_1.ForbiddenError {
    constructor(expires, acceptanceTime, tokenKey, borrower) {
        super(`AcceptLoanOffer: This offer has expired. LoanOffer.expires: ${expires}, ` +
            `TxUnixTime: ${acceptanceTime}, ` +
            `LoanOffer: ${tokenKey}, borrower: ${borrower}`, {
            expires,
            acceptanceTime,
            tokenKey,
            borrower
        });
    }
}
exports.ExpiredOfferError = ExpiredOfferError;
//# sourceMappingURL=LoanError.js.map