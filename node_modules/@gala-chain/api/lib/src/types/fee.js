"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.FeeExemptionDto = exports.SettleFeePaymentReceiptsResponse = exports.SettleFeeCreditReceiptsResponse = exports.SettleFeeBalancesResponse = exports.FeeBalanceSettlement = exports.FetchChainKeyValueObjectsWithPaginationResponse = exports.ChainKeyValueResult = exports.ChainKeysDto = exports.FetchFeeThresholdUsesWithPaginationResponse = exports.FeeThresholdUsesKeyValueResult = exports.FetchFeeThresholdUsesWithPaginationDto = exports.FetchFeeThresholdUsesResDto = exports.FetchFeeThresholdUsesDto = exports.FeeVerificationDto = exports.FeeCodeSplitFormulaDto = exports.FeeCodeDefinitionDto = exports.FeeBalanceSettlementDto = exports.FetchFeePendingBalancesResDto = exports.FeePendingBalanceKeyValueResult = exports.FetchFeePendingBalancesDto = exports.FetchFeeScheduleResDto = exports.FetchFeeScheduleDto = exports.FetchFeeCreditReceiptsResponse = exports.FeeCreditReceiptKeyValueResult = exports.FetchFeeCreditReceiptsDto = exports.FetchFeeChannelPaymentsResDto = exports.FeeChannelPaymentKeyValueResult = exports.FetchFeeChannelPaymentsDto = exports.FetchFeeAuthorizationsResDto = exports.FetchFeeAuthorizationsDto = exports.FeeAuthorizationResDto = exports.FeeAuthorizationDto = exports.FetchFeePropertiesDto = exports.FeePropertiesDto = void 0;
const tslib_1 = require("tslib");
/*
 * Copyright (c) Gala Games Inc. All rights reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const bignumber_js_1 = tslib_1.__importDefault(require("bignumber.js"));
const class_transformer_1 = require("class-transformer");
const class_validator_1 = require("class-validator");
const class_validator_jsonschema_1 = require("class-validator-jsonschema");
const validators_1 = require("../validators");
const ChainObject_1 = require("./ChainObject");
const FeeAuthorization_1 = require("./FeeAuthorization");
const FeeBalanceCreditReceipt_1 = require("./FeeBalanceCreditReceipt");
const FeeChannelPaymentReceipt_1 = require("./FeeChannelPaymentReceipt");
const FeeCodeDefinition_1 = require("./FeeCodeDefinition");
const FeeCodeSplitFormula_1 = require("./FeeCodeSplitFormula");
const FeePendingBalance_1 = require("./FeePendingBalance");
const FeeThresholdUses_1 = require("./FeeThresholdUses");
const dtos_1 = require("./dtos");
let FeePropertiesDto = class FeePropertiesDto extends dtos_1.ChainCallDTO {
};
exports.FeePropertiesDto = FeePropertiesDto;
tslib_1.__decorate([
    (0, class_validator_1.IsNotEmpty)(),
    tslib_1.__metadata("design:type", String)
], FeePropertiesDto.prototype, "collection", void 0);
tslib_1.__decorate([
    (0, class_validator_1.IsNotEmpty)(),
    tslib_1.__metadata("design:type", String)
], FeePropertiesDto.prototype, "category", void 0);
tslib_1.__decorate([
    (0, class_validator_1.IsNotEmpty)(),
    tslib_1.__metadata("design:type", String)
], FeePropertiesDto.prototype, "type", void 0);
tslib_1.__decorate([
    (0, class_validator_1.IsDefined)(),
    tslib_1.__metadata("design:type", String)
], FeePropertiesDto.prototype, "additionalKey", void 0);
tslib_1.__decorate([
    (0, class_validator_1.IsNotEmpty)(),
    (0, validators_1.BigNumberIsInteger)(),
    (0, validators_1.BigNumberIsNotNegative)(),
    (0, validators_1.BigNumberProperty)(),
    tslib_1.__metadata("design:type", bignumber_js_1.default)
], FeePropertiesDto.prototype, "instance", void 0);
tslib_1.__decorate([
    (0, class_validator_jsonschema_1.JSONSchema)({
        description: "Unique key of the DTO. It is used to prevent double execution of the same transaction on chain. " +
            "The key is saved on chain and checked before execution. " +
            "If a DTO with already saved key is used in transaction, the transaction will fail with " +
            "UniqueTransactionConflict error, which is mapped to HTTP 409 Conflict error. " +
            "In case of the error, no changes are saved to chain state.\n" +
            "The key is generated by the caller and should be unique for each DTO. " +
            "You can use `nanoid` library, UUID scheme, or any tool to generate unique string keys."
    }),
    (0, class_validator_1.IsNotEmpty)(),
    (0, class_validator_1.IsOptional)(),
    tslib_1.__metadata("design:type", String)
], FeePropertiesDto.prototype, "uniqueKey", void 0);
exports.FeePropertiesDto = FeePropertiesDto = tslib_1.__decorate([
    (0, class_validator_jsonschema_1.JSONSchema)({
        description: "Configure GALA token properties on chain for use with supporting chaincalls."
    })
], FeePropertiesDto);
let FetchFeePropertiesDto = class FetchFeePropertiesDto extends dtos_1.ChainCallDTO {
};
exports.FetchFeePropertiesDto = FetchFeePropertiesDto;
exports.FetchFeePropertiesDto = FetchFeePropertiesDto = tslib_1.__decorate([
    (0, class_validator_jsonschema_1.JSONSchema)({
        description: "Empty DTO object for Read-only chaincode execution."
    })
], FetchFeePropertiesDto);
let FeeAuthorizationDto = class FeeAuthorizationDto extends dtos_1.SubmitCallDTO {
};
exports.FeeAuthorizationDto = FeeAuthorizationDto;
tslib_1.__decorate([
    (0, class_validator_jsonschema_1.JSONSchema)({
        description: "A user authorizing a GalaChainFee payment."
    }),
    (0, validators_1.IsUserRef)(),
    tslib_1.__metadata("design:type", String)
], FeeAuthorizationDto.prototype, "authority", void 0);
tslib_1.__decorate([
    (0, class_validator_jsonschema_1.JSONSchema)({
        description: "Token Quantity authorized with this fee."
    }),
    (0, class_validator_1.IsNotEmpty)(),
    (0, validators_1.BigNumberIsNotNegative)(),
    (0, validators_1.BigNumberProperty)(),
    tslib_1.__metadata("design:type", bignumber_js_1.default)
], FeeAuthorizationDto.prototype, "quantity", void 0);
exports.FeeAuthorizationDto = FeeAuthorizationDto = tslib_1.__decorate([
    (0, class_validator_jsonschema_1.JSONSchema)({
        description: "Fee Authorization DTO. End users can authorize a Burn of $GALA to credit their " +
            "fee balance on another channel."
    })
], FeeAuthorizationDto);
let FeeAuthorizationResDto = class FeeAuthorizationResDto extends dtos_1.ChainCallDTO {
};
exports.FeeAuthorizationResDto = FeeAuthorizationResDto;
tslib_1.__decorate([
    (0, class_validator_jsonschema_1.JSONSchema)({
        description: "A serialized FeeAuthorizationDto signed by the authorizing / spending user."
    }),
    tslib_1.__metadata("design:type", String)
], FeeAuthorizationResDto.prototype, "authorization", void 0);
tslib_1.__decorate([
    (0, class_validator_jsonschema_1.JSONSchema)({
        description: "The user that authorized the GalaChainFee payment."
    }),
    (0, validators_1.IsUserAlias)(),
    tslib_1.__metadata("design:type", String)
], FeeAuthorizationResDto.prototype, "authority", void 0);
tslib_1.__decorate([
    (0, class_validator_jsonschema_1.JSONSchema)({
        description: "Unix Timestamp of fee authorization chain object creation."
    }),
    (0, class_validator_1.IsNotEmpty)(),
    tslib_1.__metadata("design:type", Number)
], FeeAuthorizationResDto.prototype, "created", void 0);
tslib_1.__decorate([
    (0, class_validator_jsonschema_1.JSONSchema)({
        description: "Transaction ID where authorization was granted for fee spend."
    }),
    (0, class_validator_1.IsNotEmpty)(),
    tslib_1.__metadata("design:type", String)
], FeeAuthorizationResDto.prototype, "txId", void 0);
tslib_1.__decorate([
    (0, class_validator_jsonschema_1.JSONSchema)({
        description: "Token Quantity authorized with this fee."
    }),
    (0, class_validator_1.IsNotEmpty)(),
    (0, validators_1.BigNumberIsNotNegative)(),
    (0, validators_1.BigNumberProperty)(),
    tslib_1.__metadata("design:type", bignumber_js_1.default)
], FeeAuthorizationResDto.prototype, "quantity", void 0);
tslib_1.__decorate([
    (0, class_validator_jsonschema_1.JSONSchema)({
        description: "Chain Key of the Fee Authorization Chain Object newly saved in World State."
    }),
    (0, class_validator_1.IsString)(),
    (0, class_validator_1.IsNotEmpty)(),
    tslib_1.__metadata("design:type", String)
], FeeAuthorizationResDto.prototype, "feeAuthorizationKey", void 0);
exports.FeeAuthorizationResDto = FeeAuthorizationResDto = tslib_1.__decorate([
    (0, class_validator_jsonschema_1.JSONSchema)({
        description: "Fee Authorization Response DTO. Data transfer object representing a successful " +
            "transaction response to a FeeAuthorization."
    })
], FeeAuthorizationResDto);
let FetchFeeAuthorizationsDto = class FetchFeeAuthorizationsDto extends dtos_1.ChainCallDTO {
};
exports.FetchFeeAuthorizationsDto = FetchFeeAuthorizationsDto;
tslib_1.__decorate([
    (0, class_validator_jsonschema_1.JSONSchema)({
        description: "Owner of the token burned to authorize a fee balance credit on another channel."
    }),
    (0, class_validator_1.IsOptional)(),
    (0, validators_1.IsUserRef)(),
    tslib_1.__metadata("design:type", String)
], FetchFeeAuthorizationsDto.prototype, "authority", void 0);
tslib_1.__decorate([
    (0, class_validator_jsonschema_1.JSONSchema)({
        description: "Year from timestamp of authorizaiton. Chain Key used for partial querying. " + "String in YYYY format."
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsNotEmpty)(),
    tslib_1.__metadata("design:type", String)
], FetchFeeAuthorizationsDto.prototype, "year", void 0);
tslib_1.__decorate([
    (0, class_validator_jsonschema_1.JSONSchema)({
        description: "Month from timestamp of authorizaiton. Chain Key used for partial querying. " + "String in MM format."
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsNotEmpty)(),
    tslib_1.__metadata("design:type", String)
], FetchFeeAuthorizationsDto.prototype, "month", void 0);
tslib_1.__decorate([
    (0, class_validator_jsonschema_1.JSONSchema)({
        description: "Day from timestamp of authorizaiton. Chain Key used for partial querying. " + "String in DD format."
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsNotEmpty)(),
    tslib_1.__metadata("design:type", String)
], FetchFeeAuthorizationsDto.prototype, "day", void 0);
tslib_1.__decorate([
    (0, class_validator_jsonschema_1.JSONSchema)({
        description: "Hour from timestamp of authorizaiton. Chain Key used for partial querying. " + "String in HH format."
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsNotEmpty)(),
    tslib_1.__metadata("design:type", String)
], FetchFeeAuthorizationsDto.prototype, "hours", void 0);
tslib_1.__decorate([
    (0, class_validator_jsonschema_1.JSONSchema)({
        description: "Minutes from timestamp of authorizaiton. Chain Key used for partial querying. " +
            "String in mm format."
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsNotEmpty)(),
    tslib_1.__metadata("design:type", String)
], FetchFeeAuthorizationsDto.prototype, "minutes", void 0);
tslib_1.__decorate([
    (0, class_validator_jsonschema_1.JSONSchema)({
        description: "feeCode identifier for which this fee was authorized. Chain key used for specific querying."
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsNotEmpty)(),
    tslib_1.__metadata("design:type", String)
], FetchFeeAuthorizationsDto.prototype, "feeCode", void 0);
tslib_1.__decorate([
    (0, class_validator_jsonschema_1.JSONSchema)({
        description: "Transaction ID where authorization was written. Chain key used for specific querying."
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsNotEmpty)(),
    tslib_1.__metadata("design:type", String)
], FetchFeeAuthorizationsDto.prototype, "txId", void 0);
tslib_1.__decorate([
    (0, class_validator_jsonschema_1.JSONSchema)({
        description: "Bookmark for pagination queries of large result sets. Used to mark place for subsequent pages of results."
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsNotEmpty)(),
    tslib_1.__metadata("design:type", String)
], FetchFeeAuthorizationsDto.prototype, "bookmark", void 0);
tslib_1.__decorate([
    (0, class_validator_jsonschema_1.JSONSchema)({
        description: "Limit number of results. Useful for pagination queries."
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsNumber)(),
    tslib_1.__metadata("design:type", Number)
], FetchFeeAuthorizationsDto.prototype, "limit", void 0);
exports.FetchFeeAuthorizationsDto = FetchFeeAuthorizationsDto = tslib_1.__decorate([
    (0, class_validator_jsonschema_1.JSONSchema)({
        description: "Fetch Fee Authorizations previously written to chain. " +
            "Optional properties can be added to narrow the search result set."
    })
], FetchFeeAuthorizationsDto);
let FetchFeeAuthorizationsResDto = class FetchFeeAuthorizationsResDto extends dtos_1.ChainCallDTO {
};
exports.FetchFeeAuthorizationsResDto = FetchFeeAuthorizationsResDto;
tslib_1.__decorate([
    (0, class_validator_jsonschema_1.JSONSchema)({ description: "List of fee authorizations." }),
    (0, class_validator_1.ValidateNested)({ each: true }),
    (0, class_transformer_1.Type)(() => FeeAuthorization_1.FeeAuthorization),
    tslib_1.__metadata("design:type", Array)
], FetchFeeAuthorizationsResDto.prototype, "results", void 0);
tslib_1.__decorate([
    (0, class_validator_jsonschema_1.JSONSchema)({ description: "Next page bookmark for large result sets." }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsNotEmpty)(),
    tslib_1.__metadata("design:type", String)
], FetchFeeAuthorizationsResDto.prototype, "nextPageBookmark", void 0);
exports.FetchFeeAuthorizationsResDto = FetchFeeAuthorizationsResDto = tslib_1.__decorate([
    (0, class_validator_jsonschema_1.JSONSchema)({
        description: "Response DTO from a successful FetchFeeAuthorizations query."
    })
], FetchFeeAuthorizationsResDto);
let FetchFeeChannelPaymentsDto = class FetchFeeChannelPaymentsDto extends dtos_1.ChainCallDTO {
};
exports.FetchFeeChannelPaymentsDto = FetchFeeChannelPaymentsDto;
tslib_1.__decorate([
    (0, class_validator_jsonschema_1.JSONSchema)({
        description: "Year from timestamp of authorizaiton. Chain Key used for partial querying. " + "String in YYYY format."
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsNotEmpty)(),
    tslib_1.__metadata("design:type", String)
], FetchFeeChannelPaymentsDto.prototype, "year", void 0);
tslib_1.__decorate([
    (0, class_validator_jsonschema_1.JSONSchema)({
        description: "Month from timestamp of authorizaiton. Chain Key used for partial querying. " + "String in MM format."
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsNotEmpty)(),
    tslib_1.__metadata("design:type", String)
], FetchFeeChannelPaymentsDto.prototype, "month", void 0);
tslib_1.__decorate([
    (0, class_validator_jsonschema_1.JSONSchema)({
        description: "Day from timestamp of authorizaiton. Chain Key used for partial querying. " + "String in DD format."
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsNotEmpty)(),
    tslib_1.__metadata("design:type", String)
], FetchFeeChannelPaymentsDto.prototype, "day", void 0);
tslib_1.__decorate([
    (0, class_validator_jsonschema_1.JSONSchema)({
        description: "Hour from timestamp of authorizaiton. Chain Key used for partial querying. " + "String in HH format."
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsNotEmpty)(),
    tslib_1.__metadata("design:type", String)
], FetchFeeChannelPaymentsDto.prototype, "hours", void 0);
tslib_1.__decorate([
    (0, class_validator_jsonschema_1.JSONSchema)({
        description: "Minutes from timestamp of authorizaiton. Chain Key used for partial querying. " +
            "String in mm format."
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsNotEmpty)(),
    tslib_1.__metadata("design:type", String)
], FetchFeeChannelPaymentsDto.prototype, "minutes", void 0);
tslib_1.__decorate([
    (0, class_validator_jsonschema_1.JSONSchema)({
        description: "feeCode identifier for which this fee was paid. Chain key used for specific querying."
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsNotEmpty)(),
    tslib_1.__metadata("design:type", String)
], FetchFeeChannelPaymentsDto.prototype, "feeCode", void 0);
tslib_1.__decorate([
    (0, class_validator_jsonschema_1.JSONSchema)({
        description: "Owner of the token burned to authorize a fee balance credit on another channel."
    }),
    (0, class_validator_1.IsOptional)(),
    (0, validators_1.IsUserRef)(),
    tslib_1.__metadata("design:type", String)
], FetchFeeChannelPaymentsDto.prototype, "paidByUser", void 0);
tslib_1.__decorate([
    (0, class_validator_jsonschema_1.JSONSchema)({
        description: "Transaction ID where authorization was written. Chain key used for specific querying."
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsNotEmpty)(),
    tslib_1.__metadata("design:type", String)
], FetchFeeChannelPaymentsDto.prototype, "txId", void 0);
tslib_1.__decorate([
    (0, class_validator_jsonschema_1.JSONSchema)({
        description: "Bookmark for pagination queries of large result sets. Used to mark place for subsequent pages of results."
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsNotEmpty)(),
    tslib_1.__metadata("design:type", String)
], FetchFeeChannelPaymentsDto.prototype, "bookmark", void 0);
tslib_1.__decorate([
    (0, class_validator_jsonschema_1.JSONSchema)({
        description: "Limit number of results. Useful for pagination queries."
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsNumber)(),
    tslib_1.__metadata("design:type", Number)
], FetchFeeChannelPaymentsDto.prototype, "limit", void 0);
exports.FetchFeeChannelPaymentsDto = FetchFeeChannelPaymentsDto = tslib_1.__decorate([
    (0, class_validator_jsonschema_1.JSONSchema)({
        description: "Fetch fee receipts."
    })
], FetchFeeChannelPaymentsDto);
let FeeChannelPaymentKeyValueResult = class FeeChannelPaymentKeyValueResult extends dtos_1.ChainCallDTO {
};
exports.FeeChannelPaymentKeyValueResult = FeeChannelPaymentKeyValueResult;
tslib_1.__decorate([
    (0, class_validator_jsonschema_1.JSONSchema)({ description: "Chain key identifying object on chain." }),
    tslib_1.__metadata("design:type", String)
], FeeChannelPaymentKeyValueResult.prototype, "key", void 0);
tslib_1.__decorate([
    (0, class_validator_jsonschema_1.JSONSchema)({ description: "Chain key identifying object on chain." }),
    (0, class_validator_1.ValidateNested)(),
    (0, class_transformer_1.Type)(() => FeeChannelPaymentReceipt_1.FeeChannelPaymentReceipt),
    tslib_1.__metadata("design:type", FeeChannelPaymentReceipt_1.FeeChannelPaymentReceipt)
], FeeChannelPaymentKeyValueResult.prototype, "value", void 0);
exports.FeeChannelPaymentKeyValueResult = FeeChannelPaymentKeyValueResult = tslib_1.__decorate([
    (0, class_validator_jsonschema_1.JSONSchema)({
        description: "FeeChannelPayment Object Value with Chain Key."
    })
], FeeChannelPaymentKeyValueResult);
let FetchFeeChannelPaymentsResDto = class FetchFeeChannelPaymentsResDto extends dtos_1.ChainCallDTO {
};
exports.FetchFeeChannelPaymentsResDto = FetchFeeChannelPaymentsResDto;
tslib_1.__decorate([
    (0, class_validator_jsonschema_1.JSONSchema)({ description: "List of fee payment receipts." }),
    (0, class_validator_1.ValidateNested)({ each: true }),
    (0, class_transformer_1.Type)(() => FeeChannelPaymentKeyValueResult),
    tslib_1.__metadata("design:type", Array)
], FetchFeeChannelPaymentsResDto.prototype, "results", void 0);
tslib_1.__decorate([
    (0, class_validator_jsonschema_1.JSONSchema)({ description: "Next page bookmark." }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsNotEmpty)(),
    tslib_1.__metadata("design:type", String)
], FetchFeeChannelPaymentsResDto.prototype, "nextPageBookmark", void 0);
exports.FetchFeeChannelPaymentsResDto = FetchFeeChannelPaymentsResDto = tslib_1.__decorate([
    (0, class_validator_jsonschema_1.JSONSchema)({
        description: "Response DTO from a successful FetchFeeChannelPayments request."
    })
], FetchFeeChannelPaymentsResDto);
let FetchFeeCreditReceiptsDto = class FetchFeeCreditReceiptsDto extends dtos_1.ChainCallDTO {
};
exports.FetchFeeCreditReceiptsDto = FetchFeeCreditReceiptsDto;
tslib_1.__decorate([
    (0, class_validator_jsonschema_1.JSONSchema)({
        description: "Year from timestamp of authorizaiton. Chain Key used for partial querying. " + "String in YYYY format."
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsNotEmpty)(),
    tslib_1.__metadata("design:type", String)
], FetchFeeCreditReceiptsDto.prototype, "year", void 0);
tslib_1.__decorate([
    (0, class_validator_jsonschema_1.JSONSchema)({
        description: "Month from timestamp of authorizaiton. Chain Key used for partial querying. " + "String in MM format."
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsNotEmpty)(),
    tslib_1.__metadata("design:type", String)
], FetchFeeCreditReceiptsDto.prototype, "month", void 0);
tslib_1.__decorate([
    (0, class_validator_jsonschema_1.JSONSchema)({
        description: "Day from timestamp of authorizaiton. Chain Key used for partial querying. " + "String in DD format."
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsNotEmpty)(),
    tslib_1.__metadata("design:type", String)
], FetchFeeCreditReceiptsDto.prototype, "day", void 0);
tslib_1.__decorate([
    (0, class_validator_jsonschema_1.JSONSchema)({
        description: "Hour from timestamp of authorizaiton. Chain Key used for partial querying. " + "String in HH format."
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsNotEmpty)(),
    tslib_1.__metadata("design:type", String)
], FetchFeeCreditReceiptsDto.prototype, "hours", void 0);
tslib_1.__decorate([
    (0, class_validator_jsonschema_1.JSONSchema)({
        description: "Minutes from timestamp of receipt creation. Chain Key used for partial querying. " +
            "String in mm format."
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsNotEmpty)(),
    tslib_1.__metadata("design:type", String)
], FetchFeeCreditReceiptsDto.prototype, "minutes", void 0);
tslib_1.__decorate([
    (0, class_validator_jsonschema_1.JSONSchema)({
        description: "feeCode identifier for which this receipt. Chain key used for specific querying."
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsNotEmpty)(),
    tslib_1.__metadata("design:type", String)
], FetchFeeCreditReceiptsDto.prototype, "feeCode", void 0);
tslib_1.__decorate([
    (0, class_validator_jsonschema_1.JSONSchema)({
        description: "Receipt issued to user."
    }),
    (0, class_validator_1.IsOptional)(),
    (0, validators_1.IsUserRef)(),
    tslib_1.__metadata("design:type", String)
], FetchFeeCreditReceiptsDto.prototype, "creditToUser", void 0);
tslib_1.__decorate([
    (0, class_validator_jsonschema_1.JSONSchema)({
        description: "Transaction ID where receipt was written. Chain key used for specific querying."
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsNotEmpty)(),
    tslib_1.__metadata("design:type", String)
], FetchFeeCreditReceiptsDto.prototype, "txId", void 0);
tslib_1.__decorate([
    (0, class_validator_jsonschema_1.JSONSchema)({
        description: "Bookmark for pagination queries of large result sets. Used to mark place for subsequent pages of results."
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsNotEmpty)(),
    tslib_1.__metadata("design:type", String)
], FetchFeeCreditReceiptsDto.prototype, "bookmark", void 0);
tslib_1.__decorate([
    (0, class_validator_jsonschema_1.JSONSchema)({
        description: "Limit number of results. Useful for pagination queries."
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsNumber)(),
    tslib_1.__metadata("design:type", Number)
], FetchFeeCreditReceiptsDto.prototype, "limit", void 0);
exports.FetchFeeCreditReceiptsDto = FetchFeeCreditReceiptsDto = tslib_1.__decorate([
    (0, class_validator_jsonschema_1.JSONSchema)({
        description: "Fetch fee receipts."
    })
], FetchFeeCreditReceiptsDto);
let FeeCreditReceiptKeyValueResult = class FeeCreditReceiptKeyValueResult extends dtos_1.ChainCallDTO {
};
exports.FeeCreditReceiptKeyValueResult = FeeCreditReceiptKeyValueResult;
tslib_1.__decorate([
    (0, class_validator_jsonschema_1.JSONSchema)({ description: "Chain key identifying object on chain." }),
    tslib_1.__metadata("design:type", String)
], FeeCreditReceiptKeyValueResult.prototype, "key", void 0);
tslib_1.__decorate([
    (0, class_validator_jsonschema_1.JSONSchema)({ description: "Chain key identifying object on chain." }),
    (0, class_validator_1.ValidateNested)(),
    (0, class_transformer_1.Type)(() => FeeChannelPaymentReceipt_1.FeeChannelPaymentReceipt),
    tslib_1.__metadata("design:type", FeeBalanceCreditReceipt_1.FeeBalanceCreditReceipt)
], FeeCreditReceiptKeyValueResult.prototype, "value", void 0);
exports.FeeCreditReceiptKeyValueResult = FeeCreditReceiptKeyValueResult = tslib_1.__decorate([
    (0, class_validator_jsonschema_1.JSONSchema)({
        description: "FeeBalanceCreditReceipt Object Value with Chain Key."
    })
], FeeCreditReceiptKeyValueResult);
let FetchFeeCreditReceiptsResponse = class FetchFeeCreditReceiptsResponse extends dtos_1.ChainCallDTO {
};
exports.FetchFeeCreditReceiptsResponse = FetchFeeCreditReceiptsResponse;
tslib_1.__decorate([
    (0, class_validator_jsonschema_1.JSONSchema)({ description: "List of fee payment receipts." }),
    (0, class_validator_1.ValidateNested)({ each: true }),
    (0, class_transformer_1.Type)(() => FeeCreditReceiptKeyValueResult),
    tslib_1.__metadata("design:type", Array)
], FetchFeeCreditReceiptsResponse.prototype, "results", void 0);
tslib_1.__decorate([
    (0, class_validator_jsonschema_1.JSONSchema)({ description: "Next page bookmark." }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsNotEmpty)(),
    tslib_1.__metadata("design:type", String)
], FetchFeeCreditReceiptsResponse.prototype, "nextPageBookmark", void 0);
exports.FetchFeeCreditReceiptsResponse = FetchFeeCreditReceiptsResponse = tslib_1.__decorate([
    (0, class_validator_jsonschema_1.JSONSchema)({
        description: "Response DTO from a successful FetchFeeCreditReceipts request."
    })
], FetchFeeCreditReceiptsResponse);
let FetchFeeScheduleDto = class FetchFeeScheduleDto extends dtos_1.ChainCallDTO {
};
exports.FetchFeeScheduleDto = FetchFeeScheduleDto;
tslib_1.__decorate([
    (0, class_validator_jsonschema_1.JSONSchema)({ description: "Limit query to a specific fee code." }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsNotEmpty)(),
    tslib_1.__metadata("design:type", String)
], FetchFeeScheduleDto.prototype, "feeCode", void 0);
exports.FetchFeeScheduleDto = FetchFeeScheduleDto = tslib_1.__decorate([
    (0, class_validator_jsonschema_1.JSONSchema)({
        description: "Query channel for Transaction FeeSchedule, comprised of currently-defined FeeCodes."
    })
], FetchFeeScheduleDto);
let FetchFeeScheduleResDto = class FetchFeeScheduleResDto extends dtos_1.ChainCallDTO {
};
exports.FetchFeeScheduleResDto = FetchFeeScheduleResDto;
tslib_1.__decorate([
    (0, class_validator_jsonschema_1.JSONSchema)({ description: "List of fee code definitions." }),
    (0, class_validator_1.ValidateNested)({ each: true }),
    (0, class_transformer_1.Type)(() => FeeCodeDefinition_1.FeeCodeDefinition),
    tslib_1.__metadata("design:type", Array)
], FetchFeeScheduleResDto.prototype, "results", void 0);
tslib_1.__decorate([
    (0, class_validator_jsonschema_1.JSONSchema)({ description: "Next page bookmark" }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsNotEmpty)(),
    tslib_1.__metadata("design:type", String)
], FetchFeeScheduleResDto.prototype, "nextPageBookmark", void 0);
exports.FetchFeeScheduleResDto = FetchFeeScheduleResDto = tslib_1.__decorate([
    (0, class_validator_jsonschema_1.JSONSchema)({
        description: "Response DTO from a successful FetchFeeSchedule request."
    })
], FetchFeeScheduleResDto);
let FetchFeePendingBalancesDto = class FetchFeePendingBalancesDto extends dtos_1.ChainCallDTO {
};
exports.FetchFeePendingBalancesDto = FetchFeePendingBalancesDto;
tslib_1.__decorate([
    (0, class_validator_jsonschema_1.JSONSchema)({ description: "(optional) Limit results to a single owner." }),
    (0, class_validator_1.IsOptional)(),
    (0, validators_1.IsUserRef)(),
    tslib_1.__metadata("design:type", String)
], FetchFeePendingBalancesDto.prototype, "owner", void 0);
tslib_1.__decorate([
    (0, class_validator_jsonschema_1.JSONSchema)({
        description: "Bookmark for pagination queries of large result sets. Used to mark place for subsequent pages of results."
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsNotEmpty)(),
    tslib_1.__metadata("design:type", String)
], FetchFeePendingBalancesDto.prototype, "bookmark", void 0);
tslib_1.__decorate([
    (0, class_validator_jsonschema_1.JSONSchema)({
        description: "Limit number of results. Useful for pagination queries."
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsNumber)(),
    tslib_1.__metadata("design:type", Number)
], FetchFeePendingBalancesDto.prototype, "limit", void 0);
exports.FetchFeePendingBalancesDto = FetchFeePendingBalancesDto = tslib_1.__decorate([
    (0, class_validator_jsonschema_1.JSONSchema)({
        description: "Fetch Pending Fee Balances. Optionally limit query to a single user. "
    })
], FetchFeePendingBalancesDto);
let FeePendingBalanceKeyValueResult = class FeePendingBalanceKeyValueResult extends dtos_1.ChainCallDTO {
};
exports.FeePendingBalanceKeyValueResult = FeePendingBalanceKeyValueResult;
tslib_1.__decorate([
    (0, class_validator_jsonschema_1.JSONSchema)({ description: "Chain key identifying object on chain." }),
    tslib_1.__metadata("design:type", String)
], FeePendingBalanceKeyValueResult.prototype, "key", void 0);
tslib_1.__decorate([
    (0, class_validator_jsonschema_1.JSONSchema)({ description: "Chain key identifying object on chain." }),
    (0, class_validator_1.ValidateNested)(),
    (0, class_transformer_1.Type)(() => FeePendingBalance_1.FeePendingBalance),
    tslib_1.__metadata("design:type", FeePendingBalance_1.FeePendingBalance)
], FeePendingBalanceKeyValueResult.prototype, "value", void 0);
exports.FeePendingBalanceKeyValueResult = FeePendingBalanceKeyValueResult = tslib_1.__decorate([
    (0, class_validator_jsonschema_1.JSONSchema)({
        description: "FeeChannelPayment Object Value with Chain Key."
    })
], FeePendingBalanceKeyValueResult);
let FetchFeePendingBalancesResDto = class FetchFeePendingBalancesResDto extends dtos_1.ChainCallDTO {
};
exports.FetchFeePendingBalancesResDto = FetchFeePendingBalancesResDto;
tslib_1.__decorate([
    (0, class_validator_jsonschema_1.JSONSchema)({ description: "List of fee pending balances." }),
    (0, class_validator_1.ValidateNested)({ each: true }),
    (0, class_transformer_1.Type)(() => FeePendingBalanceKeyValueResult),
    tslib_1.__metadata("design:type", Array)
], FetchFeePendingBalancesResDto.prototype, "results", void 0);
tslib_1.__decorate([
    (0, class_validator_jsonschema_1.JSONSchema)({ description: "Next page bookmark." }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsNotEmpty)(),
    tslib_1.__metadata("design:type", String)
], FetchFeePendingBalancesResDto.prototype, "nextPageBookmark", void 0);
exports.FetchFeePendingBalancesResDto = FetchFeePendingBalancesResDto = tslib_1.__decorate([
    (0, class_validator_jsonschema_1.JSONSchema)({
        description: "Response DTO from a successful FetchFeePendingBalances request."
    })
], FetchFeePendingBalancesResDto);
let FeeBalanceSettlementDto = class FeeBalanceSettlementDto extends dtos_1.ChainCallDTO {
};
exports.FeeBalanceSettlementDto = FeeBalanceSettlementDto;
tslib_1.__decorate([
    (0, class_validator_jsonschema_1.JSONSchema)({
        description: "Limit query/action time range. Start date as a unix timestamp. (optional)"
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsNotEmpty)(),
    tslib_1.__metadata("design:type", Number)
], FeeBalanceSettlementDto.prototype, "startDate", void 0);
tslib_1.__decorate([
    (0, class_validator_jsonschema_1.JSONSchema)({
        description: "Limit query/action time range. End date as a unix timestamp. (optional)"
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsNotEmpty)(),
    tslib_1.__metadata("design:type", Number)
], FeeBalanceSettlementDto.prototype, "endDate", void 0);
tslib_1.__decorate([
    (0, class_validator_jsonschema_1.JSONSchema)({
        description: "Limit query/action to a single user. (optional)"
    }),
    (0, class_validator_1.IsOptional)(),
    (0, validators_1.IsUserRef)(),
    tslib_1.__metadata("design:type", String)
], FeeBalanceSettlementDto.prototype, "owner", void 0);
exports.FeeBalanceSettlementDto = FeeBalanceSettlementDto = tslib_1.__decorate([
    (0, class_validator_jsonschema_1.JSONSchema)({
        description: "Settle pending fee balances. Zero out balances and convert any " +
            "pending amount to a claim/credit for $GALA."
    })
], FeeBalanceSettlementDto);
let FeeCodeDefinitionDto = class FeeCodeDefinitionDto extends dtos_1.SubmitCallDTO {
};
exports.FeeCodeDefinitionDto = FeeCodeDefinitionDto;
tslib_1.__decorate([
    (0, class_validator_1.IsString)(),
    (0, class_validator_1.IsNotEmpty)(),
    tslib_1.__metadata("design:type", String)
], FeeCodeDefinitionDto.prototype, "feeCode", void 0);
tslib_1.__decorate([
    (0, class_validator_1.IsNotEmpty)(),
    (0, validators_1.BigNumberIsNotNegative)(),
    (0, validators_1.BigNumberIsInteger)(),
    (0, validators_1.BigNumberProperty)(),
    tslib_1.__metadata("design:type", bignumber_js_1.default)
], FeeCodeDefinitionDto.prototype, "feeThresholdUses", void 0);
tslib_1.__decorate([
    (0, class_validator_1.IsNumber)(),
    tslib_1.__metadata("design:type", Number)
], FeeCodeDefinitionDto.prototype, "feeThresholdTimePeriod", void 0);
tslib_1.__decorate([
    (0, class_validator_1.IsNotEmpty)(),
    (0, validators_1.BigNumberIsNotNegative)(),
    (0, validators_1.BigNumberProperty)(),
    tslib_1.__metadata("design:type", bignumber_js_1.default)
], FeeCodeDefinitionDto.prototype, "baseQuantity", void 0);
tslib_1.__decorate([
    (0, class_validator_1.IsNotEmpty)(),
    (0, validators_1.BigNumberIsNotNegative)(),
    (0, validators_1.BigNumberProperty)(),
    tslib_1.__metadata("design:type", bignumber_js_1.default)
], FeeCodeDefinitionDto.prototype, "maxQuantity", void 0);
tslib_1.__decorate([
    (0, class_validator_jsonschema_1.JSONSchema)({
        description: "Type of FeeAccelerationRate."
    }),
    (0, validators_1.EnumProperty)(FeeCodeDefinition_1.FeeAccelerationRateType),
    tslib_1.__metadata("design:type", Number)
], FeeCodeDefinitionDto.prototype, "feeAccelerationRateType", void 0);
tslib_1.__decorate([
    (0, class_validator_1.IsNotEmpty)(),
    (0, validators_1.BigNumberProperty)(),
    tslib_1.__metadata("design:type", bignumber_js_1.default)
], FeeCodeDefinitionDto.prototype, "feeAccelerationRate", void 0);
tslib_1.__decorate([
    (0, class_validator_jsonschema_1.JSONSchema)({
        description: "(Optional) Set to 'true' to debit fees from cross-channel pending balances. " +
            "Set 'true' if $GALA is not defined on this channel. Set to 'false' or leave undefined " +
            "for fees assessed on the assets channel where users maintain their $GALA balances."
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsBoolean)(),
    tslib_1.__metadata("design:type", Boolean)
], FeeCodeDefinitionDto.prototype, "isCrossChannel", void 0);
exports.FeeCodeDefinitionDto = FeeCodeDefinitionDto = tslib_1.__decorate([
    (0, class_validator_jsonschema_1.JSONSchema)({
        description: "Define a Fee Rate Schedule for a Fee Code."
    })
], FeeCodeDefinitionDto);
let FeeCodeSplitFormulaDto = class FeeCodeSplitFormulaDto extends dtos_1.SubmitCallDTO {
};
exports.FeeCodeSplitFormulaDto = FeeCodeSplitFormulaDto;
tslib_1.__decorate([
    (0, class_validator_jsonschema_1.JSONSchema)({
        description: "feeCode which this split formula should apply to. If the FeeCodeDefinition object does not " +
            "exist on chain yet, the chaincode will throw an error. Be sure to define a FeeCodeDefinition " +
            "before attempting to define a split formula."
    }),
    (0, class_validator_1.IsString)(),
    (0, class_validator_1.IsNotEmpty)(),
    tslib_1.__metadata("design:type", String)
], FeeCodeSplitFormulaDto.prototype, "feeCode", void 0);
tslib_1.__decorate([
    (0, class_validator_jsonschema_1.JSONSchema)({
        description: "A number between 0 and 1 that represents the percentage / proportion " +
            "of the total fee which should be burned. e.g 0.9 for '90%'. "
    }),
    (0, class_validator_1.IsNumber)(),
    (0, class_validator_1.Min)(0),
    (0, class_validator_1.Max)(1),
    tslib_1.__metadata("design:type", Number)
], FeeCodeSplitFormulaDto.prototype, "burnPercentage", void 0);
tslib_1.__decorate([
    (0, class_validator_jsonschema_1.JSONSchema)({
        description: "FeeCodeTransferPercentage objects represent the identity or identities to which " +
            "a percentage (or percentages) of the paid fee should be transferred to instead of being burned."
    }),
    (0, class_validator_1.ArrayMinSize)(0),
    (0, class_validator_1.ValidateNested)({ each: true }),
    (0, class_transformer_1.Type)(() => FeeCodeSplitFormula_1.FeeCodeTransferPercentage),
    tslib_1.__metadata("design:type", Array)
], FeeCodeSplitFormulaDto.prototype, "transferPercentages", void 0);
exports.FeeCodeSplitFormulaDto = FeeCodeSplitFormulaDto = tslib_1.__decorate([
    (0, class_validator_jsonschema_1.JSONSchema)({
        description: "Define a Formula for a Fee Code that splits the Fee between a burn percentage " +
            "and one or more transfer addresses/identities, e.g. locked pools used for rewards or redemption"
    })
], FeeCodeSplitFormulaDto);
let FeeVerificationDto = class FeeVerificationDto extends dtos_1.SubmitCallDTO {
};
exports.FeeVerificationDto = FeeVerificationDto;
tslib_1.__decorate([
    (0, class_validator_jsonschema_1.JSONSchema)({
        description: "A serialized FeeAuthorizationDto signed by the authorizing / spending user."
    }),
    tslib_1.__metadata("design:type", String)
], FeeVerificationDto.prototype, "authorization", void 0);
tslib_1.__decorate([
    (0, class_validator_jsonschema_1.JSONSchema)({
        description: "The user authorizing a GalaChainFee payment. Expected to be the same user " +
            "which signed the DTO provided in the `authorization` property."
    }),
    (0, validators_1.IsUserRef)(),
    tslib_1.__metadata("design:type", String)
], FeeVerificationDto.prototype, "authority", void 0);
tslib_1.__decorate([
    (0, class_validator_jsonschema_1.JSONSchema)({
        description: "Unix Timestamp of fee authorization chain object creation."
    }),
    (0, class_validator_1.IsNotEmpty)(),
    tslib_1.__metadata("design:type", Number)
], FeeVerificationDto.prototype, "created", void 0);
tslib_1.__decorate([
    (0, class_validator_jsonschema_1.JSONSchema)({
        description: "Transaction ID where authorization was granted for fee spend."
    }),
    (0, class_validator_1.IsNotEmpty)(),
    tslib_1.__metadata("design:type", String)
], FeeVerificationDto.prototype, "txId", void 0);
tslib_1.__decorate([
    (0, class_validator_jsonschema_1.JSONSchema)({
        description: "Token Quantity authorized with this fee."
    }),
    (0, class_validator_1.IsNotEmpty)(),
    (0, validators_1.BigNumberIsNotNegative)(),
    (0, validators_1.BigNumberProperty)(),
    tslib_1.__metadata("design:type", bignumber_js_1.default)
], FeeVerificationDto.prototype, "quantity", void 0);
tslib_1.__decorate([
    (0, class_validator_jsonschema_1.JSONSchema)({
        description: "Chain Key referencing Fee Authorization Chain Object saved in World State."
    }),
    (0, class_validator_1.IsString)(),
    (0, class_validator_1.IsNotEmpty)(),
    tslib_1.__metadata("design:type", String)
], FeeVerificationDto.prototype, "feeAuthorizationKey", void 0);
exports.FeeVerificationDto = FeeVerificationDto = tslib_1.__decorate([
    (0, class_validator_jsonschema_1.JSONSchema)({
        description: "Fee Verification DTO. With a valid signature from an Authoritative User, " +
            "used to verify that a Fee was paid across channels. " +
            "Typically, this will be a type of multi-signature DTO or a double signed DTO. " +
            "That is, the `authorization` property contains the original authorization DTO signed by " +
            "the End User. And the overall FeeVerificationDto will be signed by an Authoritative/Administrative " +
            "user (i.e. a CuratorUser). The Chaincode can then verify definitively that both a) the end user did " +
            "authorize a spend, and b) the Authoritative/Administrative user confirms that this authorization was " +
            "successfully approved/written/burned on the assets channel."
    })
], FeeVerificationDto);
let FetchFeeThresholdUsesDto = class FetchFeeThresholdUsesDto extends dtos_1.ChainCallDTO {
};
exports.FetchFeeThresholdUsesDto = FetchFeeThresholdUsesDto;
tslib_1.__decorate([
    (0, class_validator_jsonschema_1.JSONSchema)({
        description: "feeCode identifier for which this fee was paid."
    }),
    (0, class_validator_1.IsString)(),
    (0, class_validator_1.IsNotEmpty)(),
    tslib_1.__metadata("design:type", String)
], FetchFeeThresholdUsesDto.prototype, "feeCode", void 0);
tslib_1.__decorate([
    (0, class_validator_jsonschema_1.JSONSchema)({ description: "user who paid this fee." }),
    (0, class_validator_1.IsString)(),
    (0, validators_1.IsUserRef)(),
    tslib_1.__metadata("design:type", String)
], FetchFeeThresholdUsesDto.prototype, "user", void 0);
exports.FetchFeeThresholdUsesDto = FetchFeeThresholdUsesDto = tslib_1.__decorate([
    (0, class_validator_jsonschema_1.JSONSchema)({
        description: "Fetch Fee Threshold Uses for a Fee Code and User."
    })
], FetchFeeThresholdUsesDto);
let FetchFeeThresholdUsesResDto = class FetchFeeThresholdUsesResDto extends dtos_1.ChainCallDTO {
};
exports.FetchFeeThresholdUsesResDto = FetchFeeThresholdUsesResDto;
tslib_1.__decorate([
    (0, class_validator_jsonschema_1.JSONSchema)({
        description: "feeCode identifier for which this fee was paid."
    }),
    (0, class_validator_1.IsString)(),
    (0, class_validator_1.IsNotEmpty)(),
    tslib_1.__metadata("design:type", String)
], FetchFeeThresholdUsesResDto.prototype, "feeCode", void 0);
tslib_1.__decorate([
    (0, class_validator_jsonschema_1.JSONSchema)({ description: "user who paid this fee." }),
    (0, class_validator_1.IsString)(),
    (0, validators_1.IsUserRef)(),
    tslib_1.__metadata("design:type", String)
], FetchFeeThresholdUsesResDto.prototype, "user", void 0);
tslib_1.__decorate([
    (0, class_validator_jsonschema_1.JSONSchema)({ description: "total cumulative uses of this fee." }),
    (0, class_validator_1.IsNotEmpty)(),
    (0, validators_1.BigNumberIsNotNegative)(),
    (0, validators_1.BigNumberIsInteger)(),
    (0, validators_1.BigNumberProperty)(),
    tslib_1.__metadata("design:type", bignumber_js_1.default)
], FetchFeeThresholdUsesResDto.prototype, "cumulativeUses", void 0);
tslib_1.__decorate([
    (0, class_validator_jsonschema_1.JSONSchema)({ description: "total cumulative quantity of this fee." }),
    (0, class_validator_1.IsNotEmpty)(),
    (0, validators_1.BigNumberIsNotNegative)(),
    (0, validators_1.BigNumberProperty)(),
    tslib_1.__metadata("design:type", bignumber_js_1.default)
], FetchFeeThresholdUsesResDto.prototype, "cumulativeFeeQuantity", void 0);
exports.FetchFeeThresholdUsesResDto = FetchFeeThresholdUsesResDto = tslib_1.__decorate([
    (0, class_validator_jsonschema_1.JSONSchema)({
        description: "Response DTO from a successful FetchFeeThresholdUses request."
    })
], FetchFeeThresholdUsesResDto);
let FetchFeeThresholdUsesWithPaginationDto = class FetchFeeThresholdUsesWithPaginationDto extends dtos_1.ChainCallDTO {
};
exports.FetchFeeThresholdUsesWithPaginationDto = FetchFeeThresholdUsesWithPaginationDto;
tslib_1.__decorate([
    (0, class_validator_jsonschema_1.JSONSchema)({
        description: "feeCode identifier to limit search results."
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsString)(),
    (0, class_validator_1.IsNotEmpty)(),
    tslib_1.__metadata("design:type", String)
], FetchFeeThresholdUsesWithPaginationDto.prototype, "feeCode", void 0);
tslib_1.__decorate([
    (0, class_validator_jsonschema_1.JSONSchema)({ description: "Next page bookmark." }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsNotEmpty)(),
    tslib_1.__metadata("design:type", String)
], FetchFeeThresholdUsesWithPaginationDto.prototype, "bookmark", void 0);
tslib_1.__decorate([
    (0, class_validator_jsonschema_1.JSONSchema)({
        description: "Limit number of results. Useful for pagination queries."
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsNumber)(),
    tslib_1.__metadata("design:type", Number)
], FetchFeeThresholdUsesWithPaginationDto.prototype, "limit", void 0);
exports.FetchFeeThresholdUsesWithPaginationDto = FetchFeeThresholdUsesWithPaginationDto = tslib_1.__decorate([
    (0, class_validator_jsonschema_1.JSONSchema)({
        description: "Fetch Fee Threshold Uses with pagination. Optionally limit by feeCode."
    })
], FetchFeeThresholdUsesWithPaginationDto);
let FeeThresholdUsesKeyValueResult = class FeeThresholdUsesKeyValueResult extends dtos_1.ChainCallDTO {
};
exports.FeeThresholdUsesKeyValueResult = FeeThresholdUsesKeyValueResult;
tslib_1.__decorate([
    (0, class_validator_jsonschema_1.JSONSchema)({ description: "Chain key identifying object on chain." }),
    tslib_1.__metadata("design:type", String)
], FeeThresholdUsesKeyValueResult.prototype, "key", void 0);
tslib_1.__decorate([
    (0, class_validator_jsonschema_1.JSONSchema)({ description: "Chain key identifying object on chain." }),
    (0, class_validator_1.ValidateNested)(),
    (0, class_transformer_1.Type)(() => ChainObject_1.ChainObject),
    tslib_1.__metadata("design:type", FeeThresholdUses_1.FeeThresholdUses)
], FeeThresholdUsesKeyValueResult.prototype, "value", void 0);
exports.FeeThresholdUsesKeyValueResult = FeeThresholdUsesKeyValueResult = tslib_1.__decorate([
    (0, class_validator_jsonschema_1.JSONSchema)({
        description: "Chain Object Value with Chain Key."
    })
], FeeThresholdUsesKeyValueResult);
let FetchFeeThresholdUsesWithPaginationResponse = class FetchFeeThresholdUsesWithPaginationResponse extends dtos_1.ChainCallDTO {
};
exports.FetchFeeThresholdUsesWithPaginationResponse = FetchFeeThresholdUsesWithPaginationResponse;
tslib_1.__decorate([
    (0, class_validator_jsonschema_1.JSONSchema)({ description: "List of FeeThresholdUses." }),
    (0, class_validator_1.ValidateNested)({ each: true }),
    (0, class_transformer_1.Type)(() => FeeThresholdUsesKeyValueResult),
    tslib_1.__metadata("design:type", Array)
], FetchFeeThresholdUsesWithPaginationResponse.prototype, "results", void 0);
tslib_1.__decorate([
    (0, class_validator_jsonschema_1.JSONSchema)({ description: "Next page bookmark." }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsNotEmpty)(),
    tslib_1.__metadata("design:type", String)
], FetchFeeThresholdUsesWithPaginationResponse.prototype, "nextPageBookmark", void 0);
exports.FetchFeeThresholdUsesWithPaginationResponse = FetchFeeThresholdUsesWithPaginationResponse = tslib_1.__decorate([
    (0, class_validator_jsonschema_1.JSONSchema)({
        description: "Response DTO from a Fetch Fee Threshold Uses with pagination request."
    })
], FetchFeeThresholdUsesWithPaginationResponse);
let ChainKeysDto = class ChainKeysDto extends dtos_1.SubmitCallDTO {
};
exports.ChainKeysDto = ChainKeysDto;
tslib_1.__decorate([
    (0, class_validator_jsonschema_1.JSONSchema)({
        description: "A list of composite keys to pass to getObjectsByKeys method."
    }),
    (0, class_validator_1.ArrayNotEmpty)(),
    (0, class_validator_1.ArrayMaxSize)(100000),
    (0, class_validator_1.ArrayUnique)(),
    tslib_1.__metadata("design:type", Array)
], ChainKeysDto.prototype, "chainKeys", void 0);
exports.ChainKeysDto = ChainKeysDto = tslib_1.__decorate([
    (0, class_validator_jsonschema_1.JSONSchema)({
        description: "Take an action on a set of provided chain keys, acquired from a fetch response. " +
            "E.g. ResetFeeThresholds, SettleFeePaymentReceipts, etc."
    })
], ChainKeysDto);
let ChainKeyValueResult = class ChainKeyValueResult extends dtos_1.ChainCallDTO {
};
exports.ChainKeyValueResult = ChainKeyValueResult;
tslib_1.__decorate([
    (0, class_validator_jsonschema_1.JSONSchema)({ description: "Chain key identifying object on chain." }),
    tslib_1.__metadata("design:type", String)
], ChainKeyValueResult.prototype, "key", void 0);
tslib_1.__decorate([
    (0, class_validator_jsonschema_1.JSONSchema)({ description: "Chain key identifying object on chain." }),
    (0, class_validator_1.ValidateNested)(),
    (0, class_transformer_1.Type)(() => ChainObject_1.ChainObject),
    tslib_1.__metadata("design:type", ChainObject_1.ChainObject)
], ChainKeyValueResult.prototype, "value", void 0);
exports.ChainKeyValueResult = ChainKeyValueResult = tslib_1.__decorate([
    (0, class_validator_jsonschema_1.JSONSchema)({
        description: "Chain Object Value with Chain Key."
    })
], ChainKeyValueResult);
let FetchChainKeyValueObjectsWithPaginationResponse = class FetchChainKeyValueObjectsWithPaginationResponse extends dtos_1.ChainCallDTO {
};
exports.FetchChainKeyValueObjectsWithPaginationResponse = FetchChainKeyValueObjectsWithPaginationResponse;
tslib_1.__decorate([
    (0, class_validator_jsonschema_1.JSONSchema)({ description: "List of FeeThresholdUses." }),
    (0, class_validator_1.ValidateNested)({ each: true }),
    (0, class_transformer_1.Type)(() => ChainKeyValueResult),
    tslib_1.__metadata("design:type", Array)
], FetchChainKeyValueObjectsWithPaginationResponse.prototype, "results", void 0);
tslib_1.__decorate([
    (0, class_validator_jsonschema_1.JSONSchema)({ description: "Next page bookmark." }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsNotEmpty)(),
    tslib_1.__metadata("design:type", String)
], FetchChainKeyValueObjectsWithPaginationResponse.prototype, "nextPageBookmark", void 0);
exports.FetchChainKeyValueObjectsWithPaginationResponse = FetchChainKeyValueObjectsWithPaginationResponse = tslib_1.__decorate([
    (0, class_validator_jsonschema_1.JSONSchema)({
        description: "Response DTO from a Fetch Fee* Pagination request."
    })
], FetchChainKeyValueObjectsWithPaginationResponse);
let FeeBalanceSettlement = class FeeBalanceSettlement extends dtos_1.ChainCallDTO {
};
exports.FeeBalanceSettlement = FeeBalanceSettlement;
tslib_1.__decorate([
    (0, class_validator_jsonschema_1.JSONSchema)({
        description: "The FeePendingBalance which was settled."
    }),
    (0, class_validator_1.ValidateNested)(),
    (0, class_transformer_1.Type)(() => FeePendingBalance_1.FeePendingBalance),
    tslib_1.__metadata("design:type", FeePendingBalance_1.FeePendingBalance)
], FeeBalanceSettlement.prototype, "balance", void 0);
tslib_1.__decorate([
    (0, class_validator_jsonschema_1.JSONSchema)({
        description: "If the value was greater than 0, the credit receipt issued."
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.ValidateNested)(),
    (0, class_transformer_1.Type)(() => FeeBalanceCreditReceipt_1.FeeBalanceCreditReceipt),
    tslib_1.__metadata("design:type", Object)
], FeeBalanceSettlement.prototype, "receipt", void 0);
exports.FeeBalanceSettlement = FeeBalanceSettlement = tslib_1.__decorate([
    (0, class_validator_jsonschema_1.JSONSchema)({
        description: "FeeBalanceSettlement"
    })
], FeeBalanceSettlement);
let SettleFeeBalancesResponse = class SettleFeeBalancesResponse extends dtos_1.ChainCallDTO {
};
exports.SettleFeeBalancesResponse = SettleFeeBalancesResponse;
tslib_1.__decorate([
    (0, class_validator_jsonschema_1.JSONSchema)({
        description: "Results set"
    }),
    (0, class_validator_1.ValidateNested)({ each: true }),
    (0, class_transformer_1.Type)(() => FeeBalanceSettlement),
    tslib_1.__metadata("design:type", Array)
], SettleFeeBalancesResponse.prototype, "results", void 0);
exports.SettleFeeBalancesResponse = SettleFeeBalancesResponse = tslib_1.__decorate([
    (0, class_validator_jsonschema_1.JSONSchema)({
        description: "Response DTO from a SettleFeeBalances request."
    })
], SettleFeeBalancesResponse);
let SettleFeeCreditReceiptsResponse = class SettleFeeCreditReceiptsResponse extends dtos_1.ChainCallDTO {
};
exports.SettleFeeCreditReceiptsResponse = SettleFeeCreditReceiptsResponse;
tslib_1.__decorate([
    (0, class_validator_jsonschema_1.JSONSchema)({
        description: "Results set"
    }),
    (0, class_validator_1.ValidateNested)({ each: true }),
    (0, class_transformer_1.Type)(() => FeeBalanceCreditReceipt_1.FeeBalanceCreditReceipt),
    tslib_1.__metadata("design:type", Array)
], SettleFeeCreditReceiptsResponse.prototype, "results", void 0);
exports.SettleFeeCreditReceiptsResponse = SettleFeeCreditReceiptsResponse = tslib_1.__decorate([
    (0, class_validator_jsonschema_1.JSONSchema)({
        description: "Response DTO from a SettleFeeCreditReceipts request."
    })
], SettleFeeCreditReceiptsResponse);
let SettleFeePaymentReceiptsResponse = class SettleFeePaymentReceiptsResponse extends dtos_1.ChainCallDTO {
};
exports.SettleFeePaymentReceiptsResponse = SettleFeePaymentReceiptsResponse;
tslib_1.__decorate([
    (0, class_validator_jsonschema_1.JSONSchema)({
        description: "Results set"
    }),
    (0, class_validator_1.ValidateNested)({ each: true }),
    (0, class_transformer_1.Type)(() => FeeChannelPaymentReceipt_1.FeeChannelPaymentReceipt),
    tslib_1.__metadata("design:type", Array)
], SettleFeePaymentReceiptsResponse.prototype, "results", void 0);
exports.SettleFeePaymentReceiptsResponse = SettleFeePaymentReceiptsResponse = tslib_1.__decorate([
    (0, class_validator_jsonschema_1.JSONSchema)({
        description: "Response DTO from a SettleFeePaymentReceipts request."
    })
], SettleFeePaymentReceiptsResponse);
let FeeExemptionDto = class FeeExemptionDto extends dtos_1.SubmitCallDTO {
};
exports.FeeExemptionDto = FeeExemptionDto;
tslib_1.__decorate([
    (0, class_validator_jsonschema_1.JSONSchema)({
        description: "The user / identity that should be exempt from fees."
    }),
    (0, class_validator_1.IsString)(),
    (0, validators_1.IsUserRef)(),
    tslib_1.__metadata("design:type", String)
], FeeExemptionDto.prototype, "user", void 0);
tslib_1.__decorate([
    (0, class_validator_jsonschema_1.JSONSchema)({
        description: "(Optional). If provided, the user's exemption will be limited to the provided fee codes."
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.ArrayUnique)(),
    tslib_1.__metadata("design:type", Array)
], FeeExemptionDto.prototype, "limitTo", void 0);
exports.FeeExemptionDto = FeeExemptionDto = tslib_1.__decorate([
    (0, class_validator_jsonschema_1.JSONSchema)({
        description: "Define a FeeExemption for a specific user."
    })
], FeeExemptionDto);
//# sourceMappingURL=fee.js.map