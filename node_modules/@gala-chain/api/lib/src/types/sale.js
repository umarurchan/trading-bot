"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TokenSaleFailedError = exports.TokenSaleDtoValidationError = exports.EnsureTokenSaleIndexingResponse = exports.EnsureTokenSaleIndexingDto = exports.FetchTokenSaleByIdDto = exports.FetchTokenSalesWithPaginationResponse = exports.FetchTokenSalesWithPaginationDto = exports.RemoveTokenSaleDto = exports.FulfillTokenSaleDto = exports.ExpectedTokenSale = exports.CreateTokenSaleDto = exports.TokenSaleFulfillment = exports.TokenSaleMintAllowance = exports.TokenSaleOwner = exports.TokenSaleTokenCost = exports.TokenSaleTokenSold = exports.TokenSale = exports.TokenSaleQuantity = void 0;
const tslib_1 = require("tslib");
/*
 * Copyright (c) Gala Games Inc. All rights reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const bignumber_js_1 = tslib_1.__importDefault(require("bignumber.js"));
const class_transformer_1 = require("class-transformer");
const class_validator_1 = require("class-validator");
const class_validator_jsonschema_1 = require("class-validator-jsonschema");
const utils_1 = require("../utils");
const validators_1 = require("../validators");
const ChainObject_1 = require("./ChainObject");
const TokenClass_1 = require("./TokenClass");
const dtos_1 = require("./dtos");
let TokenSaleQuantity = class TokenSaleQuantity {
};
exports.TokenSaleQuantity = TokenSaleQuantity;
tslib_1.__decorate([
    (0, class_validator_jsonschema_1.JSONSchema)({
        description: "Token class key of the token to be sold."
    }),
    (0, class_validator_1.ValidateNested)(),
    (0, class_transformer_1.Type)(() => TokenClass_1.TokenClassKey),
    (0, class_validator_1.IsNotEmpty)(),
    tslib_1.__metadata("design:type", TokenClass_1.TokenClassKey)
], TokenSaleQuantity.prototype, "tokenClassKey", void 0);
tslib_1.__decorate([
    (0, class_validator_jsonschema_1.JSONSchema)({
        description: "Quantity of tokens to be received."
    }),
    (0, class_validator_1.IsNotEmpty)(),
    (0, validators_1.BigNumberIsPositive)(),
    (0, validators_1.BigNumberIsInteger)(),
    (0, validators_1.BigNumberProperty)(),
    tslib_1.__metadata("design:type", bignumber_js_1.default)
], TokenSaleQuantity.prototype, "quantity", void 0);
exports.TokenSaleQuantity = TokenSaleQuantity = tslib_1.__decorate([
    (0, class_validator_jsonschema_1.JSONSchema)({
        description: "Defines a sale token with quantity of tokens to be received"
    })
], TokenSaleQuantity);
// Chain objects
let TokenSale = class TokenSale extends ChainObject_1.ChainObject {
};
exports.TokenSale = TokenSale;
TokenSale.INDEX_KEY = "GCTTS";
tslib_1.__decorate([
    (0, class_validator_jsonschema_1.JSONSchema)({
        description: "Timestamp of when the sale was created"
    }),
    (0, utils_1.ChainKey)({ position: 0 }),
    (0, class_validator_1.IsNumber)(),
    tslib_1.__metadata("design:type", Number)
], TokenSale.prototype, "created", void 0);
tslib_1.__decorate([
    (0, class_validator_jsonschema_1.JSONSchema)({
        description: "Transaction ID"
    }),
    (0, utils_1.ChainKey)({ position: 1 }),
    (0, class_validator_1.IsNotEmpty)(),
    tslib_1.__metadata("design:type", String)
], TokenSale.prototype, "txid", void 0);
tslib_1.__decorate([
    (0, class_validator_jsonschema_1.JSONSchema)({
        description: "Token sale ID"
    }),
    (0, class_validator_1.IsNotEmpty)(),
    tslib_1.__metadata("design:type", String)
], TokenSale.prototype, "tokenSaleId", void 0);
tslib_1.__decorate([
    (0, class_validator_jsonschema_1.JSONSchema)({
        description: "Tokens and quantities to be sold"
    }),
    (0, class_validator_1.ValidateNested)({ each: true }),
    (0, class_transformer_1.Type)(() => TokenSaleQuantity),
    (0, class_validator_1.ArrayNotEmpty)(),
    tslib_1.__metadata("design:type", Array)
], TokenSale.prototype, "selling", void 0);
tslib_1.__decorate([
    (0, class_validator_jsonschema_1.JSONSchema)({
        description: "Tokens and quantities to be received"
    }),
    (0, class_validator_1.ValidateNested)({ each: true }),
    (0, class_transformer_1.Type)(() => TokenSaleQuantity),
    (0, class_validator_1.ArrayNotEmpty)(),
    tslib_1.__metadata("design:type", Array)
], TokenSale.prototype, "cost", void 0);
tslib_1.__decorate([
    (0, class_validator_jsonschema_1.JSONSchema)({
        description: "User who created the sale"
    }),
    (0, validators_1.IsUserAlias)(),
    tslib_1.__metadata("design:type", String)
], TokenSale.prototype, "owner", void 0);
tslib_1.__decorate([
    (0, class_validator_jsonschema_1.JSONSchema)({
        description: "Ids of each sale fullfillment"
    }),
    (0, class_validator_1.IsNotEmpty)(),
    tslib_1.__metadata("design:type", Array)
], TokenSale.prototype, "fulfillmentIds", void 0);
tslib_1.__decorate([
    (0, class_validator_jsonschema_1.JSONSchema)({
        description: "Token quantity of items being sold"
    }),
    (0, validators_1.BigNumberIsPositive)(),
    (0, validators_1.BigNumberIsInteger)(),
    (0, validators_1.BigNumberProperty)(),
    tslib_1.__metadata("design:type", bignumber_js_1.default)
], TokenSale.prototype, "quantity", void 0);
tslib_1.__decorate([
    (0, class_validator_jsonschema_1.JSONSchema)({
        description: "Quantity of items sold"
    }),
    (0, validators_1.BigNumberIsPositive)(),
    (0, validators_1.BigNumberIsInteger)(),
    (0, validators_1.BigNumberProperty)(),
    tslib_1.__metadata("design:type", bignumber_js_1.default)
], TokenSale.prototype, "quantityFulfilled", void 0);
tslib_1.__decorate([
    (0, class_validator_jsonschema_1.JSONSchema)({
        description: "Timestamp when sale ends"
    }),
    (0, class_validator_1.Min)(0),
    (0, class_validator_1.IsInt)(),
    tslib_1.__metadata("design:type", Number)
], TokenSale.prototype, "end", void 0);
tslib_1.__decorate([
    (0, class_validator_jsonschema_1.JSONSchema)({
        description: "Timestamp when sale starts"
    }),
    (0, class_validator_1.Min)(0),
    (0, class_validator_1.IsInt)(),
    tslib_1.__metadata("design:type", Number)
], TokenSale.prototype, "start", void 0);
tslib_1.__decorate([
    (0, class_transformer_1.Exclude)(),
    tslib_1.__metadata("design:type", Object)
], TokenSale, "INDEX_KEY", void 0);
exports.TokenSale = TokenSale = tslib_1.__decorate([
    (0, class_validator_jsonschema_1.JSONSchema)({
        description: "Defines a token sale. A sale is a collection of tokens to be sold, and the quantity of each token to be received."
    })
], TokenSale);
class TokenSaleTokenSold extends ChainObject_1.ChainObject {
}
exports.TokenSaleTokenSold = TokenSaleTokenSold;
TokenSaleTokenSold.INDEX_KEY = `${TokenSale.INDEX_KEY}TS`;
tslib_1.__decorate([
    (0, utils_1.ChainKey)({ position: 0 }),
    (0, class_validator_1.IsNotEmpty)(),
    tslib_1.__metadata("design:type", String)
], TokenSaleTokenSold.prototype, "collection", void 0);
tslib_1.__decorate([
    (0, utils_1.ChainKey)({ position: 1 }),
    tslib_1.__metadata("design:type", String)
], TokenSaleTokenSold.prototype, "category", void 0);
tslib_1.__decorate([
    (0, utils_1.ChainKey)({ position: 2 }),
    (0, class_validator_1.IsNotEmpty)(),
    tslib_1.__metadata("design:type", String)
], TokenSaleTokenSold.prototype, "type", void 0);
tslib_1.__decorate([
    (0, utils_1.ChainKey)({ position: 3 }),
    (0, class_validator_1.IsNotEmpty)(),
    tslib_1.__metadata("design:type", String)
], TokenSaleTokenSold.prototype, "additionalKey", void 0);
tslib_1.__decorate([
    (0, utils_1.ChainKey)({ position: 4 }),
    (0, validators_1.BigNumberIsPositive)(),
    (0, validators_1.BigNumberIsInteger)(),
    (0, validators_1.BigNumberProperty)(),
    tslib_1.__metadata("design:type", String)
], TokenSaleTokenSold.prototype, "quantity", void 0);
tslib_1.__decorate([
    (0, utils_1.ChainKey)({ position: 5 }),
    (0, class_validator_1.IsNotEmpty)(),
    tslib_1.__metadata("design:type", String)
], TokenSaleTokenSold.prototype, "tokenSaleId", void 0);
class TokenSaleTokenCost extends ChainObject_1.ChainObject {
}
exports.TokenSaleTokenCost = TokenSaleTokenCost;
TokenSaleTokenCost.INDEX_KEY = `${TokenSale.INDEX_KEY}TC`;
tslib_1.__decorate([
    (0, utils_1.ChainKey)({ position: 0 }),
    (0, class_validator_1.IsNotEmpty)(),
    tslib_1.__metadata("design:type", String)
], TokenSaleTokenCost.prototype, "collection", void 0);
tslib_1.__decorate([
    (0, utils_1.ChainKey)({ position: 1 }),
    tslib_1.__metadata("design:type", String)
], TokenSaleTokenCost.prototype, "category", void 0);
tslib_1.__decorate([
    (0, utils_1.ChainKey)({ position: 2 }),
    (0, class_validator_1.IsNotEmpty)(),
    tslib_1.__metadata("design:type", String)
], TokenSaleTokenCost.prototype, "type", void 0);
tslib_1.__decorate([
    (0, utils_1.ChainKey)({ position: 3 }),
    (0, class_validator_1.IsNotEmpty)(),
    tslib_1.__metadata("design:type", String)
], TokenSaleTokenCost.prototype, "additionalKey", void 0);
tslib_1.__decorate([
    (0, utils_1.ChainKey)({ position: 4 }),
    (0, validators_1.BigNumberIsPositive)(),
    (0, validators_1.BigNumberIsInteger)(),
    (0, validators_1.BigNumberProperty)(),
    tslib_1.__metadata("design:type", String)
], TokenSaleTokenCost.prototype, "quantity", void 0);
tslib_1.__decorate([
    (0, utils_1.ChainKey)({ position: 5 }),
    (0, class_validator_1.IsNotEmpty)(),
    tslib_1.__metadata("design:type", String)
], TokenSaleTokenCost.prototype, "tokenSaleId", void 0);
class TokenSaleOwner extends ChainObject_1.ChainObject {
}
exports.TokenSaleOwner = TokenSaleOwner;
TokenSaleOwner.INDEX_KEY = `${TokenSale.INDEX_KEY}O`;
tslib_1.__decorate([
    (0, utils_1.ChainKey)({ position: 0 }),
    (0, validators_1.IsUserAlias)(),
    tslib_1.__metadata("design:type", String)
], TokenSaleOwner.prototype, "owner", void 0);
tslib_1.__decorate([
    (0, utils_1.ChainKey)({ position: 1 }),
    (0, class_validator_1.IsNotEmpty)(),
    tslib_1.__metadata("design:type", String)
], TokenSaleOwner.prototype, "tokenSaleId", void 0);
class TokenSaleMintAllowance extends ChainObject_1.ChainObject {
}
exports.TokenSaleMintAllowance = TokenSaleMintAllowance;
TokenSaleMintAllowance.INDEX_KEY = `${TokenSale.INDEX_KEY}MA`;
tslib_1.__decorate([
    (0, utils_1.ChainKey)({ position: 0 }),
    (0, class_validator_1.IsNotEmpty)(),
    tslib_1.__metadata("design:type", String)
], TokenSaleMintAllowance.prototype, "tokenSaleId", void 0);
tslib_1.__decorate([
    (0, utils_1.ChainKey)({ position: 1 }),
    (0, class_validator_1.IsNotEmpty)(),
    tslib_1.__metadata("design:type", String)
], TokenSaleMintAllowance.prototype, "collection", void 0);
tslib_1.__decorate([
    (0, utils_1.ChainKey)({ position: 2 }),
    (0, class_validator_1.IsNotEmpty)(),
    tslib_1.__metadata("design:type", String)
], TokenSaleMintAllowance.prototype, "category", void 0);
tslib_1.__decorate([
    (0, utils_1.ChainKey)({ position: 3 }),
    (0, class_validator_1.IsNotEmpty)(),
    tslib_1.__metadata("design:type", String)
], TokenSaleMintAllowance.prototype, "type", void 0);
tslib_1.__decorate([
    (0, utils_1.ChainKey)({ position: 4 }),
    (0, class_validator_1.IsNotEmpty)(),
    tslib_1.__metadata("design:type", String)
], TokenSaleMintAllowance.prototype, "additionalKey", void 0);
tslib_1.__decorate([
    (0, utils_1.ChainKey)({ position: 5 }),
    (0, validators_1.BigNumberIsPositive)(),
    (0, validators_1.BigNumberProperty)(),
    tslib_1.__metadata("design:type", bignumber_js_1.default)
], TokenSaleMintAllowance.prototype, "quantity", void 0);
tslib_1.__decorate([
    (0, utils_1.ChainKey)({ position: 6 }),
    (0, class_validator_1.IsNotEmpty)(),
    tslib_1.__metadata("design:type", String)
], TokenSaleMintAllowance.prototype, "allowanceObjectKey", void 0);
class TokenSaleFulfillment extends ChainObject_1.ChainObject {
}
exports.TokenSaleFulfillment = TokenSaleFulfillment;
TokenSaleFulfillment.INDEX_KEY = "GCTSF";
tslib_1.__decorate([
    (0, utils_1.ChainKey)({ position: 0 }),
    (0, class_validator_1.IsNotEmpty)(),
    tslib_1.__metadata("design:type", String)
], TokenSaleFulfillment.prototype, "tokenSaleId", void 0);
tslib_1.__decorate([
    (0, utils_1.ChainKey)({ position: 1 }),
    (0, validators_1.IsUserAlias)(),
    tslib_1.__metadata("design:type", String)
], TokenSaleFulfillment.prototype, "fulfilledBy", void 0);
tslib_1.__decorate([
    (0, utils_1.ChainKey)({ position: 2 }),
    (0, class_validator_1.IsPositive)(),
    tslib_1.__metadata("design:type", Number)
], TokenSaleFulfillment.prototype, "created", void 0);
tslib_1.__decorate([
    (0, validators_1.BigNumberIsPositive)(),
    (0, validators_1.BigNumberProperty)(),
    tslib_1.__metadata("design:type", bignumber_js_1.default)
], TokenSaleFulfillment.prototype, "quantity", void 0);
// Chain DTOs
let CreateTokenSaleDto = class CreateTokenSaleDto extends dtos_1.SubmitCallDTO {
};
exports.CreateTokenSaleDto = CreateTokenSaleDto;
CreateTokenSaleDto.DEFAULT_END = 0;
CreateTokenSaleDto.DEFAULT_START = 0;
tslib_1.__decorate([
    (0, class_validator_jsonschema_1.JSONSchema)({
        description: "User who creates the token sale, typically an authority of the token. " +
            "Optional field, by default set to chaincode calling user."
    }),
    (0, class_validator_1.IsOptional)(),
    (0, validators_1.IsUserRef)(),
    tslib_1.__metadata("design:type", String)
], CreateTokenSaleDto.prototype, "owner", void 0);
tslib_1.__decorate([
    (0, class_validator_jsonschema_1.JSONSchema)({
        description: "A list of offered tokens to be sold."
    }),
    (0, class_validator_1.ValidateNested)({ each: true }),
    (0, class_transformer_1.Type)(() => TokenSaleQuantity),
    (0, class_validator_1.ArrayMinSize)(1),
    (0, class_validator_1.ArrayUnique)(),
    tslib_1.__metadata("design:type", Array)
], CreateTokenSaleDto.prototype, "selling", void 0);
tslib_1.__decorate([
    (0, class_validator_jsonschema_1.JSONSchema)({
        description: "A list of tokens to be paid to the seller."
    }),
    (0, class_validator_1.ValidateNested)({ each: true }),
    (0, class_transformer_1.Type)(() => TokenSaleQuantity),
    (0, class_validator_1.ArrayMinSize)(1),
    (0, class_validator_1.ArrayUnique)(),
    tslib_1.__metadata("design:type", Array)
], CreateTokenSaleDto.prototype, "cost", void 0);
tslib_1.__decorate([
    (0, class_validator_jsonschema_1.JSONSchema)({
        description: "How many sale items can be purchased."
    }),
    (0, validators_1.BigNumberIsPositive)(),
    (0, validators_1.BigNumberIsInteger)(),
    (0, validators_1.BigNumberProperty)(),
    tslib_1.__metadata("design:type", bignumber_js_1.default)
], CreateTokenSaleDto.prototype, "quantity", void 0);
tslib_1.__decorate([
    (0, class_validator_jsonschema_1.JSONSchema)({
        description: "Unix timestamp of the date when the sale should end. 0 means that it won't end. " +
            `By default set to ${CreateTokenSaleDto.DEFAULT_END}.`
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.Min)(0),
    (0, class_validator_1.IsInt)(),
    tslib_1.__metadata("design:type", Number)
], CreateTokenSaleDto.prototype, "end", void 0);
tslib_1.__decorate([
    (0, class_validator_jsonschema_1.JSONSchema)({
        description: "Unix timestamp of the date when the sale should start. 0 means that it starts immediately. " +
            `By default set to ${CreateTokenSaleDto.DEFAULT_START}.`
    }),
    tslib_1.__metadata("design:type", Number)
], CreateTokenSaleDto.prototype, "start", void 0);
exports.CreateTokenSaleDto = CreateTokenSaleDto = tslib_1.__decorate([
    (0, class_validator_jsonschema_1.JSONSchema)({
        description: "Defines a swap request to be created, i.e. a request when a requester " +
            "offers some tokens to another user in exchange of another tokens."
    })
], CreateTokenSaleDto);
let ExpectedTokenSale = class ExpectedTokenSale {
};
exports.ExpectedTokenSale = ExpectedTokenSale;
tslib_1.__decorate([
    (0, class_validator_jsonschema_1.JSONSchema)({
        description: "A list of purchasable token classes and quantities. The order of this array must match the order of the TokenSale stored on chain."
    }),
    (0, class_validator_1.ValidateNested)({ each: true }),
    (0, class_transformer_1.Type)(() => TokenSaleQuantity),
    (0, class_validator_1.ArrayMinSize)(1),
    (0, class_validator_1.ArrayUnique)(),
    tslib_1.__metadata("design:type", Array)
], ExpectedTokenSale.prototype, "selling", void 0);
tslib_1.__decorate([
    (0, class_validator_jsonschema_1.JSONSchema)({
        description: "A list of cost token classes and quantites. The order of this array must match the order of the TokenSale stored on chain."
    }),
    (0, class_validator_1.ValidateNested)({ each: true }),
    (0, class_transformer_1.Type)(() => TokenSaleQuantity),
    (0, class_validator_1.ArrayMinSize)(1),
    (0, class_validator_1.ArrayUnique)(),
    tslib_1.__metadata("design:type", Array)
], ExpectedTokenSale.prototype, "cost", void 0);
exports.ExpectedTokenSale = ExpectedTokenSale = tslib_1.__decorate([
    (0, class_validator_jsonschema_1.JSONSchema)({
        description: "Defines an expected token swap trade, i.e. offered and wanted tokens."
    })
], ExpectedTokenSale);
let FulfillTokenSaleDto = class FulfillTokenSaleDto extends dtos_1.SubmitCallDTO {
};
exports.FulfillTokenSaleDto = FulfillTokenSaleDto;
tslib_1.__decorate([
    (0, class_validator_jsonschema_1.JSONSchema)({
        description: "Token sale ID to be filled"
    }),
    (0, class_validator_1.IsNotEmpty)(),
    tslib_1.__metadata("design:type", String)
], FulfillTokenSaleDto.prototype, "tokenSaleId", void 0);
tslib_1.__decorate([
    (0, class_validator_jsonschema_1.JSONSchema)({
        description: "Expected token sale to be validated before filling the swap."
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.ValidateNested)(),
    (0, class_transformer_1.Type)(() => ExpectedTokenSale),
    tslib_1.__metadata("design:type", ExpectedTokenSale)
], FulfillTokenSaleDto.prototype, "expectedTokenSale", void 0);
tslib_1.__decorate([
    (0, class_validator_jsonschema_1.JSONSchema)({
        description: "User who fulfills the sale, an owner of tokens wanted in swap. " +
            "Optional field, by default set to chaincode calling user."
    }),
    (0, class_validator_1.IsOptional)(),
    (0, validators_1.IsUserAlias)(),
    tslib_1.__metadata("design:type", String)
], FulfillTokenSaleDto.prototype, "fulfilledBy", void 0);
tslib_1.__decorate([
    (0, class_validator_jsonschema_1.JSONSchema)({
        description: "The quantity of items to be purchased "
    }),
    (0, validators_1.BigNumberIsPositive)(),
    (0, validators_1.BigNumberIsInteger)(),
    (0, validators_1.BigNumberProperty)(),
    tslib_1.__metadata("design:type", bignumber_js_1.default)
], FulfillTokenSaleDto.prototype, "quantity", void 0);
exports.FulfillTokenSaleDto = FulfillTokenSaleDto = tslib_1.__decorate([
    (0, class_validator_jsonschema_1.JSONSchema)({
        description: "Defines a swap fill object, i.e. a response of another user for a swap request."
    })
], FulfillTokenSaleDto);
class RemoveTokenSaleDto extends dtos_1.SubmitCallDTO {
}
exports.RemoveTokenSaleDto = RemoveTokenSaleDto;
tslib_1.__decorate([
    (0, class_validator_jsonschema_1.JSONSchema)({
        description: "Token sale ID to be removed."
    }),
    (0, class_validator_1.IsNotEmpty)(),
    tslib_1.__metadata("design:type", String)
], RemoveTokenSaleDto.prototype, "tokenSaleId", void 0);
let FetchTokenSalesWithPaginationDto = class FetchTokenSalesWithPaginationDto extends dtos_1.ChainCallDTO {
};
exports.FetchTokenSalesWithPaginationDto = FetchTokenSalesWithPaginationDto;
FetchTokenSalesWithPaginationDto.MAX_LIMIT = 10 * 1000;
FetchTokenSalesWithPaginationDto.DEFAULT_LIMIT = 1000;
tslib_1.__decorate([
    (0, class_validator_jsonschema_1.JSONSchema)({
        description: "(optional). User alias of the creating user."
    }),
    (0, class_validator_1.IsOptional)(),
    (0, validators_1.IsUserRef)(),
    tslib_1.__metadata("design:type", String)
], FetchTokenSalesWithPaginationDto.prototype, "owner", void 0);
tslib_1.__decorate([
    (0, class_validator_jsonschema_1.JSONSchema)({
        description: "Page bookmark. If it is undefined, then the first page is returned."
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsNotEmpty)(),
    tslib_1.__metadata("design:type", String)
], FetchTokenSalesWithPaginationDto.prototype, "bookmark", void 0);
tslib_1.__decorate([
    (0, class_validator_jsonschema_1.JSONSchema)({
        description: `Page size limit. ` +
            `Defaults to ${FetchTokenSalesWithPaginationDto.DEFAULT_LIMIT}, max possible value ${FetchTokenSalesWithPaginationDto.MAX_LIMIT}. ` +
            "Note you will likely get less results than the limit, because the limit is applied before additional filtering."
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.Max)(FetchTokenSalesWithPaginationDto.MAX_LIMIT),
    (0, class_validator_1.Min)(1),
    (0, class_validator_1.IsInt)(),
    tslib_1.__metadata("design:type", Number)
], FetchTokenSalesWithPaginationDto.prototype, "limit", void 0);
exports.FetchTokenSalesWithPaginationDto = FetchTokenSalesWithPaginationDto = tslib_1.__decorate([
    (0, class_validator_jsonschema_1.JSONSchema)({
        description: "Legacy FetchTokenSwapsDto. Provided created timestamp to limit result, or leave empty to query all swaps."
    })
], FetchTokenSalesWithPaginationDto);
let FetchTokenSalesWithPaginationResponse = class FetchTokenSalesWithPaginationResponse extends dtos_1.ChainCallDTO {
};
exports.FetchTokenSalesWithPaginationResponse = FetchTokenSalesWithPaginationResponse;
tslib_1.__decorate([
    (0, class_validator_1.IsOptional)(),
    tslib_1.__metadata("design:type", Object)
], FetchTokenSalesWithPaginationResponse.prototype, "nextPageBookmark", void 0);
tslib_1.__decorate([
    (0, class_validator_1.ValidateNested)({ each: true }),
    (0, class_transformer_1.Type)(() => TokenSale),
    tslib_1.__metadata("design:type", Array)
], FetchTokenSalesWithPaginationResponse.prototype, "results", void 0);
exports.FetchTokenSalesWithPaginationResponse = FetchTokenSalesWithPaginationResponse = tslib_1.__decorate([
    (0, class_validator_jsonschema_1.JSONSchema)({
        description: "Response DTO for FetchTokenSwaps{ByInstanceOffered|ByInstanceWanted|OfferedBy|OfferedTo} methods. Supports pagination."
    })
], FetchTokenSalesWithPaginationResponse);
class FetchTokenSaleByIdDto extends dtos_1.ChainCallDTO {
}
exports.FetchTokenSaleByIdDto = FetchTokenSaleByIdDto;
tslib_1.__decorate([
    (0, class_validator_jsonschema_1.JSONSchema)({
        description: "Token sale ID."
    }),
    (0, class_validator_1.IsNotEmpty)(),
    tslib_1.__metadata("design:type", String)
], FetchTokenSaleByIdDto.prototype, "tokenSaleId", void 0);
let EnsureTokenSaleIndexingDto = class EnsureTokenSaleIndexingDto extends dtos_1.ChainCallDTO {
};
exports.EnsureTokenSaleIndexingDto = EnsureTokenSaleIndexingDto;
tslib_1.__decorate([
    (0, class_validator_1.ArrayNotEmpty)(),
    tslib_1.__metadata("design:type", Array)
], EnsureTokenSaleIndexingDto.prototype, "tokenSaleIds", void 0);
exports.EnsureTokenSaleIndexingDto = EnsureTokenSaleIndexingDto = tslib_1.__decorate([
    (0, class_validator_jsonschema_1.JSONSchema)({
        description: "Ensure that provided tokenSaleId chain objects have proper supporting index Chain Objects. " +
            "This method permits migration / upgrade of TokenSales written prior to the advent of new index objects " +
            "which were added to support fine-grained querying of TokenSale by client applications. " +
            "The provided tokenSaleIds will be looked up on chain, then their corresponding index Chain objects will be queried and written if necessary."
    })
], EnsureTokenSaleIndexingDto);
let EnsureTokenSaleIndexingResponse = class EnsureTokenSaleIndexingResponse extends dtos_1.ChainCallDTO {
};
exports.EnsureTokenSaleIndexingResponse = EnsureTokenSaleIndexingResponse;
tslib_1.__decorate([
    (0, class_validator_1.IsBoolean)(),
    tslib_1.__metadata("design:type", Boolean)
], EnsureTokenSaleIndexingResponse.prototype, "noOp", void 0);
tslib_1.__decorate([
    (0, class_validator_1.ArrayMinSize)(0),
    tslib_1.__metadata("design:type", Array)
], EnsureTokenSaleIndexingResponse.prototype, "writes", void 0);
exports.EnsureTokenSaleIndexingResponse = EnsureTokenSaleIndexingResponse = tslib_1.__decorate([
    (0, class_validator_jsonschema_1.JSONSchema)({
        description: "Response DTO for a EnsureTokenSaleIndexing request. If any writes were made, they will be provided in the writes array and noOp will be true."
    })
], EnsureTokenSaleIndexingResponse);
// Errors
class TokenSaleDtoValidationError extends utils_1.ValidationFailedError {
    constructor(dtoName, errors) {
        super(`${dtoName} validation failed: ${errors.join(". ")}`, {
            dtoName,
            errors
        });
    }
}
exports.TokenSaleDtoValidationError = TokenSaleDtoValidationError;
class TokenSaleFailedError extends utils_1.ValidationFailedError {
    constructor(message, payload) {
        super(`SwapToken failed: ${message}$`, payload);
    }
}
exports.TokenSaleFailedError = TokenSaleFailedError;
//# sourceMappingURL=sale.js.map