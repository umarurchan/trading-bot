import { BigNumber } from "bignumber.js";
import { ValidationFailedError } from "../utils";
import { ChainObject } from "./ChainObject";
import { TokenClassKeyProperties } from "./TokenClass";
import { UserAlias } from "./UserAlias";
export declare class TokenNotInBalanceError extends ValidationFailedError {
    constructor(owner: string, tokenClass: TokenClassKeyProperties, instanceId: BigNumber);
}
export declare class TokenLockedError extends ValidationFailedError {
    constructor(owner: string, tokenClass: TokenClassKeyProperties, instanceId: BigNumber, name: string | undefined);
}
export declare class TokenNotLockedError extends ValidationFailedError {
    constructor(owner: string, tokenClass: TokenClassKeyProperties, instanceId: BigNumber);
}
export declare class TokenQuantityNotUnlockedError extends ValidationFailedError {
    constructor(owner: string, tokenClass: TokenClassKeyProperties, quantity: BigNumber, name: string | undefined);
}
export declare class TokenInUseError extends ValidationFailedError {
    constructor(owner: string, tokenClass: TokenClassKeyProperties, instanceId: BigNumber);
}
export declare class TokenNotInUseError extends ValidationFailedError {
    constructor(owner: string, tokenClass: TokenClassKeyProperties, instanceId: BigNumber);
}
export declare class TokenBalance extends ChainObject {
    static readonly INDEX_KEY = "GCTB";
    readonly owner: UserAlias;
    readonly collection: string;
    readonly category: string;
    readonly type: string;
    readonly additionalKey: string;
    constructor(params?: {
        owner: UserAlias;
        collection: string;
        category: string;
        type: string;
        additionalKey: string;
    });
    /**
     * Token instance IDs for NFTs. It is also used to determine if the balance is
     * for fungible or non-fungible tokens. If the array is undefined, then the
     * balance is for fungible tokens.
     */
    private instanceIds?;
    private lockedHolds?;
    private inUseHolds?;
    private quantity;
    vestingPeriodStart?: number | undefined;
    getNftInstanceCount(): number;
    getUnexpiredLockedHolds(currentTime: number): TokenHold[];
    getUnexpiredLockedHoldsSortedByAscendingExpiration(currentTime: number): TokenHold[];
    getUnexpiredInUseHolds(currentTime: number): TokenHold[];
    addInstance(instanceId: BigNumber): void;
    removeInstance(instanceId: BigNumber, currentTime: number): void;
    lockInstance(hold: TokenHold, currentTime: number): void;
    unlockInstance(instanceId: BigNumber, name: string | undefined, currentTime: number): void;
    useInstance(hold: TokenHold, currentTime: number): void;
    releaseInstance(instanceId: BigNumber, name: string | undefined, currentTime: number): void;
    clearHolds(instanceId: BigNumber, currentTime: number): void;
    findLockedHold(instanceId: BigNumber, name: string | undefined, currentTime: number): TokenHold | undefined;
    findInUseHold(instanceId: BigNumber, currentTime: number): TokenHold | undefined;
    containsAnyNftInstanceId(): boolean;
    isInstanceSpendable(instanceId: BigNumber, currentTime: number): boolean;
    getNftInstanceIds(): BigNumber[];
    cleanupExpiredHolds(currentTime: number): TokenBalance;
    private containsInstance;
    private isInstanceLocked;
    private isInstanceInUse;
    private ensureInstanceIsNft;
    private ensureInstanceIsInBalance;
    private ensureInstanceIsNotLockedWithTheSameName;
    private ensureInstanceIsNotLocked;
    private ensureInstanceIsNotUsed;
    getQuantityTotal(): BigNumber;
    getSpendableQuantityTotal(currentTime: number): BigNumber;
    getLockedQuantityTotal(currentTime: number): BigNumber;
    addQuantity(quantity: BigNumber): void;
    subtractQuantity(quantity: BigNumber, currentTime: number): void;
    private ensureQuantityIsSpendable;
    private ensureTokenQuantityHoldIsFungible;
    lockQuantity(hold: TokenHold): void;
    private isCallingUserAuthorized;
    unlockQuantity(quantity: BigNumber, currentTime: number, name?: string, callingUser?: UserAlias, isTokenAuthority?: boolean): void;
    private getCurrentLockedQuantity;
    private ensureContainsNoNftInstances;
    private ensureIsValidQuantityForFungible;
}
export declare class TokenHold {
    static readonly DEFAULT_EXPIRES = 0;
    readonly createdBy: UserAlias;
    readonly instanceId: BigNumber;
    readonly quantity: BigNumber;
    readonly created: number;
    readonly expires: number;
    readonly name?: string;
    lockAuthority?: UserAlias;
    readonly vestingPeriodStart?: number | undefined;
    constructor(params?: {
        createdBy: UserAlias;
        instanceId: BigNumber;
        quantity: BigNumber;
        created: number;
        expires?: number;
        name?: string;
        lockAuthority?: UserAlias;
        vestingPeriodStart?: number | undefined;
    });
    static createValid(params: {
        createdBy: UserAlias;
        instanceId: BigNumber;
        quantity: BigNumber;
        created: number;
        expires: number | undefined;
        name: string | undefined;
        lockAuthority: UserAlias | undefined;
        vestingPeriodStart: number | undefined;
    }): Promise<TokenHold>;
    matches(instanceId: BigNumber, name: string | undefined): boolean;
    isExpired(currentTime: number): boolean;
    isVestingHold(): boolean;
    isVestingStarted(currentTime: number): boolean;
    timeSinceStart(currentTime: number): number;
    totalTimeOfVestingPeriod(): number;
    getLockedVestingQuantity(currentTime: number): BigNumber;
    static sortByAscendingExpiration(a: TokenHold, b: TokenHold): 0 | 1 | -1;
}
//# sourceMappingURL=TokenBalance.d.ts.map