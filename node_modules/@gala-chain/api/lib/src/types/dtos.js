"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.GetMyProfileDto = exports.GetPublicKeyDto = exports.UpdateUserRolesDto = exports.UpdatePublicKeyDto = exports.RegisterTonUserDto = exports.RegisterEthUserDto = exports.RegisterUserDto = exports.DryRunResultDto = exports.DryRunDto = exports.GetObjectHistoryDto = exports.GetObjectDto = exports.BatchDto = exports.BatchOperationDto = exports.SubmitCallDTO = exports.ChainCallDTO = exports.createValidSubmitDTO = exports.createValidDTO = exports.parseValidDTO = exports.validateDTO = void 0;
const tslib_1 = require("tslib");
/*
 * Copyright (c) Gala Games Inc. All rights reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const class_transformer_1 = require("class-transformer");
const class_validator_1 = require("class-validator");
const class_validator_jsonschema_1 = require("class-validator-jsonschema");
const utils_1 = require("../utils");
const validators_1 = require("../validators");
class DtoValidationFailedError extends utils_1.ValidationFailedError {
    constructor(errors) {
        const messages = (0, utils_1.getValidationErrorMessages)(errors);
        const messagesString = messages.map((s, i) => `(${i + 1}) ${s}`).join(", ");
        super(`DTO validation failed: ${messagesString}`, messages);
    }
}
const validateDTO = async (dto) => {
    const validationErrors = await dto.validate();
    if (validationErrors.length) {
        throw new DtoValidationFailedError(validationErrors);
    }
    else {
        return dto;
    }
};
exports.validateDTO = validateDTO;
/**
 * Parses JSON string and creates a Promise with valid DTO. Throws exception in case of validation errors.
 */
const parseValidDTO = async (constructor, jsonStringOrObj) => {
    const deserialized = ChainCallDTO.deserialize(constructor, jsonStringOrObj);
    await (0, exports.validateDTO)(deserialized);
    return deserialized;
};
exports.parseValidDTO = parseValidDTO;
/**
 * Creates valid DTO object from provided plain object.
 * Throws exception in case of validation errors.
 */
function createValidDTO(constructor, plain) {
    const instance = (0, class_transformer_1.plainToInstance)(constructor, plain);
    const response = (0, exports.validateDTO)(instance);
    // @ts-expect-error adding new method in runtime
    response.signed = (k) => response.then((r) => r.signed(k));
    return response;
}
exports.createValidDTO = createValidDTO;
/**
 * Creates valid submit DTO object from provided plain object.
 * Throws exception in case of validation errors.
 * If the uniqueKey is not provided, it generates a random one: 32 random bytes in base64.
 */
function createValidSubmitDTO(constructor, plain) {
    var _a;
    return createValidDTO(constructor, {
        ...plain,
        uniqueKey: (_a = plain === null || plain === void 0 ? void 0 : plain.uniqueKey) !== null && _a !== void 0 ? _a : (0, utils_1.randomUniqueKey)()
    });
}
exports.createValidSubmitDTO = createValidSubmitDTO;
/**
 * @description
 *
 * The base DTO (Data Transfer Object) class. Provides common properties and
 * methods for signing, uniqueness, validation, and serialization. All other DTOs in the
 * SDK extend from this base class. To implement custom a custom DTO, create a new class that
 * extends `ChainCallDTO`, and use the `class-validator` npm package to decorate
 * the properties of the new class.
 *
 * @remarks
 *
 * Additional details for specific properties of this class
 * are generated via the `class-validator-jsonschema` npm module and can either
 *  be viewed in the source code
 * or in the OpenAPI documentation served alongside GalaChain's API endpoints.
 */
class ChainCallDTO {
    validate() {
        return (0, class_validator_1.validate)(this);
    }
    async validateOrReject() {
        const validationErrors = await this.validate();
        if (validationErrors.length) {
            throw new DtoValidationFailedError(validationErrors);
        }
    }
    /**
     * @description
     *
     * Serialze this object to string in a determinsitic fashion.
     * See Hyperledger Fabric's documentation on
     * [JSON Determinism](https://hyperledger-fabric.readthedocs.io/en/release-2.5/chaincode4ade.html#json-determinism)
     * for more details.
     *
     * @returns string
     */
    serialize() {
        return (0, utils_1.serialize)(this);
    }
    /**
     * @description
     *
     * Instantiate a class instance from a serialized object using the provided `ClassConstructor`.
     *
     * @param constructor
     *
     * `ClassConstructor` that extends `ChainCallDTO`
     *
     * @param object
     *
     * serialized string or plain object to be instantiated via the provided `ClassConstructor`
     *
     * @returns
     *
     * An instantiated class created with the provided `ClassConstructor`
     */
    static deserialize(constructor, object) {
        return (0, utils_1.deserialize)(constructor, object);
    }
    sign(privateKey, useDer = false) {
        if (useDer) {
            if (this.signing === utils_1.SigningScheme.TON) {
                throw new utils_1.ValidationFailedError("TON signing scheme does not support DER signatures");
            }
            else {
                if (this.signerPublicKey === undefined && this.signerAddress === undefined) {
                    this.signerPublicKey = utils_1.signatures.getPublicKey(privateKey);
                }
            }
        }
        if (this.signing === utils_1.SigningScheme.TON) {
            const keyBuffer = Buffer.from(privateKey, "base64");
            this.signature = utils_1.signatures.ton.getSignature(this, keyBuffer, this.prefix).toString("base64");
        }
        else {
            const keyBuffer = utils_1.signatures.normalizePrivateKey(privateKey);
            this.signature = useDer
                ? utils_1.signatures.getDERSignature(this, keyBuffer)
                : utils_1.signatures.getSignature(this, keyBuffer);
        }
    }
    /**
     * Creates a signed copy of current object.
     */
    // note: previously it was typed as "typeof this", but it's failed randomly on compilation
    signed(privateKey, useDer = false) {
        const copied = (0, class_transformer_1.instanceToInstance)(this);
        copied.sign(privateKey, useDer);
        return copied;
    }
    isSignatureValid(publicKey) {
        var _a, _b;
        if (this.signing === utils_1.SigningScheme.TON) {
            const signatureBuff = Buffer.from((_a = this.signature) !== null && _a !== void 0 ? _a : "", "base64");
            const publicKeyBuff = Buffer.from(publicKey, "base64");
            return utils_1.signatures.ton.isValidSignature(signatureBuff, this, publicKeyBuff, this.prefix);
        }
        else {
            return utils_1.signatures.isValid((_b = this.signature) !== null && _b !== void 0 ? _b : "", this, publicKey);
        }
    }
}
exports.ChainCallDTO = ChainCallDTO;
tslib_1.__decorate([
    (0, class_validator_jsonschema_1.JSONSchema)({
        description: "Unique key of the DTO. It is used to prevent double execution of the same transaction on chain. " +
            "The key is saved on chain and checked before execution. " +
            "If a DTO with already saved key is used in transaction, the transaction will fail with " +
            "UniqueTransactionConflict error, which is mapped to HTTP 409 Conflict error. " +
            "In case of the error, no changes are saved to chain state.\n" +
            "The key is generated by the caller and should be unique for each DTO. " +
            "You can use `nanoid` library, UUID scheme, or any tool to generate unique string keys."
    }),
    (0, class_validator_1.IsNotEmpty)(),
    (0, class_validator_1.IsOptional)(),
    tslib_1.__metadata("design:type", String)
], ChainCallDTO.prototype, "uniqueKey", void 0);
tslib_1.__decorate([
    (0, class_validator_jsonschema_1.JSONSchema)({
        description: "Signature of the DTO signed with caller's private key to be verified with user's public key saved on chain. " +
            "The 'signature' field is optional for DTO, but is required for a transaction to be executed on chain. \n" +
            "Please consult [GalaChain SDK documentation](https://github.com/GalaChain/sdk/blob/main/docs/authorization.md#signature-based-authorization) on how to create signatures."
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsNotEmpty)(),
    tslib_1.__metadata("design:type", String)
], ChainCallDTO.prototype, "signature", void 0);
tslib_1.__decorate([
    (0, class_validator_jsonschema_1.JSONSchema)({
        description: "Prefix for Metamask transaction signatures. " +
            "Necessary to format payloads correctly to recover publicKey from web3 signatures."
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsNotEmpty)(),
    tslib_1.__metadata("design:type", String)
], ChainCallDTO.prototype, "prefix", void 0);
tslib_1.__decorate([
    (0, class_validator_jsonschema_1.JSONSchema)({
        description: "Address of the user who signed the DTO. Typically Ethereum or TON address."
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsNotEmpty)(),
    tslib_1.__metadata("design:type", String)
], ChainCallDTO.prototype, "signerAddress", void 0);
tslib_1.__decorate([
    (0, class_validator_jsonschema_1.JSONSchema)({
        description: "Public key of the user who signed the DTO."
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsNotEmpty)(),
    tslib_1.__metadata("design:type", String)
], ChainCallDTO.prototype, "signerPublicKey", void 0);
tslib_1.__decorate([
    (0, class_validator_jsonschema_1.JSONSchema)({
        description: `Signing scheme used for the signature. ` +
            `"${utils_1.SigningScheme.ETH}" for Ethereum, and "${utils_1.SigningScheme.TON}" for The Open Network are supported. ` +
            `Default: "${utils_1.SigningScheme.ETH}".`
    }),
    (0, class_validator_1.IsOptional)(),
    (0, validators_1.StringEnumProperty)(utils_1.SigningScheme),
    tslib_1.__metadata("design:type", String)
], ChainCallDTO.prototype, "signing", void 0);
tslib_1.__decorate([
    (0, class_validator_jsonschema_1.JSONSchema)({
        description: "Unit timestamp when the DTO expires. If the timestamp is in the past, the DTO is not valid."
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsNumber)(),
    tslib_1.__metadata("design:type", Number)
], ChainCallDTO.prototype, "dtoExpiresAt", void 0);
// It just makes uniqueKey required
class SubmitCallDTO extends ChainCallDTO {
}
exports.SubmitCallDTO = SubmitCallDTO;
tslib_1.__decorate([
    (0, class_validator_1.IsNotEmpty)(),
    tslib_1.__metadata("design:type", String)
], SubmitCallDTO.prototype, "uniqueKey", void 0);
class BatchOperationDto extends ChainCallDTO {
}
exports.BatchOperationDto = BatchOperationDto;
tslib_1.__decorate([
    (0, class_validator_1.IsNotEmpty)(),
    tslib_1.__metadata("design:type", String)
], BatchOperationDto.prototype, "method", void 0);
tslib_1.__decorate([
    (0, class_validator_1.IsNotEmpty)(),
    (0, class_validator_1.ValidateNested)(),
    (0, class_transformer_1.Type)(() => ChainCallDTO),
    tslib_1.__metadata("design:type", ChainCallDTO)
], BatchOperationDto.prototype, "dto", void 0);
class BatchDto extends ChainCallDTO {
}
exports.BatchDto = BatchDto;
BatchDto.BATCH_SIZE_LIMIT = 1000;
BatchDto.WRITES_DEFAULT_LIMIT = 10000;
BatchDto.WRITES_HARD_LIMIT = 100000;
tslib_1.__decorate([
    (0, class_validator_jsonschema_1.JSONSchema)({
        description: "Soft limit of keys written to chain in a batch, excluding deletes. " +
            "If the limit is exceeded, all subsequent operations in batch fail. " +
            "Typically it is safe to repeat failed operations in the next batch. " +
            `Default: ${BatchDto.WRITES_DEFAULT_LIMIT}. ` +
            `Max: ${BatchDto.WRITES_HARD_LIMIT}.`
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsNumber)(),
    (0, class_validator_1.Min)(1),
    (0, class_validator_1.Max)(BatchDto.WRITES_HARD_LIMIT),
    (0, class_validator_1.IsOptional)(),
    tslib_1.__metadata("design:type", Number)
], BatchDto.prototype, "writesLimit", void 0);
tslib_1.__decorate([
    (0, class_validator_jsonschema_1.JSONSchema)({
        description: "If true, the batch will fail if any of the operations fail. " +
            "If false, the batch will continue even if some of the operations fail. " +
            "Default: false."
    }),
    (0, class_validator_1.IsOptional)(),
    tslib_1.__metadata("design:type", Boolean)
], BatchDto.prototype, "noPartialSuccess", void 0);
tslib_1.__decorate([
    (0, class_transformer_1.Type)(() => BatchOperationDto),
    (0, class_validator_1.ValidateNested)({ each: true }),
    (0, class_validator_1.ArrayMinSize)(1),
    (0, class_validator_1.ArrayMaxSize)(BatchDto.BATCH_SIZE_LIMIT),
    tslib_1.__metadata("design:type", Array)
], BatchDto.prototype, "operations", void 0);
/**
 * @description
 *
 * Input for the `GetObjectByKey` chaincode method defined on the GalaContract class.
 */
class GetObjectDto extends ChainCallDTO {
}
exports.GetObjectDto = GetObjectDto;
tslib_1.__decorate([
    (0, class_validator_1.IsNotEmpty)(),
    tslib_1.__metadata("design:type", String)
], GetObjectDto.prototype, "objectId", void 0);
/**
 * @description
 *
 * Input for the `GetObjectByHistory` chaincode method defined on the GalaContract class.
 */
class GetObjectHistoryDto extends ChainCallDTO {
}
exports.GetObjectHistoryDto = GetObjectHistoryDto;
tslib_1.__decorate([
    (0, class_validator_1.IsNotEmpty)(),
    tslib_1.__metadata("design:type", String)
], GetObjectHistoryDto.prototype, "objectId", void 0);
/**
 * @description
 *
 * Input for the `DryRun` chaincode method defined on the GalaContract class.
 * Use a `DryRunDto` and the `DryRun` chaincode method to simulate the
 * execution of a chaincode contract method. The results of the `DryRun`
 * will not be written chain. Instead, the Read/Write set that would have resulted from
 * the transaction will be returned to the consuming client for analysis.
 *
 * @remarks
 *
 * Authorization is not checked for `DryRun` execution. This allows application,
 * administrative, game server identities etc. to simulate a transaction result
 * without prompting the end user to sign the input first. This helps avoid
 * replay attacks (as the unique id would not be written to chain in a DryRun)
 * and also allows applications to present certain outcomes to the end user
 * before they decide to sign and authorize the transaction.
 *
 * Example use case: Executing a `DryRun` on a given method, and then processing
 * the results for `FeeChannelPaymentReceipt` or `FeeUserPaymentReceipt` objects
 * can yield the exepcted/estimated fee prior to executing a transaction. The
 * estimated fee can then be presented to an end user for them to decide whether
 * or not they want to authorize the transaction.
 */
class DryRunDto extends ChainCallDTO {
}
exports.DryRunDto = DryRunDto;
tslib_1.__decorate([
    (0, class_validator_1.IsNotEmpty)(),
    tslib_1.__metadata("design:type", String)
], DryRunDto.prototype, "method", void 0);
tslib_1.__decorate([
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsNotEmpty)(),
    tslib_1.__metadata("design:type", String)
], DryRunDto.prototype, "callerPublicKey", void 0);
tslib_1.__decorate([
    (0, class_validator_1.IsNotEmpty)(),
    (0, class_validator_1.IsOptional)(),
    (0, class_transformer_1.Type)(() => ChainCallDTO),
    tslib_1.__metadata("design:type", ChainCallDTO)
], DryRunDto.prototype, "dto", void 0);
/**
 * @description
 *
 * Data Transfer Object (DTO) representing the  results of a successful `DryRun` execution,
 * to be sent back to the  consuming client.
 */
class DryRunResultDto extends ChainCallDTO {
}
exports.DryRunResultDto = DryRunResultDto;
/**
 * @description
 *
 * Dto for secure method to save public keys for legacy users.
 * Method is called and signed by Curators
 */
let RegisterUserDto = class RegisterUserDto extends SubmitCallDTO {
};
exports.RegisterUserDto = RegisterUserDto;
tslib_1.__decorate([
    (0, class_validator_jsonschema_1.JSONSchema)({
        description: `Id of user to save public key for.`
    }),
    (0, validators_1.IsUserAlias)(),
    tslib_1.__metadata("design:type", String)
], RegisterUserDto.prototype, "user", void 0);
tslib_1.__decorate([
    (0, class_validator_jsonschema_1.JSONSchema)({ description: "Public secp256k1 key (compact or non-compact, hex or base64)." }),
    (0, class_validator_1.IsNotEmpty)(),
    tslib_1.__metadata("design:type", String)
], RegisterUserDto.prototype, "publicKey", void 0);
exports.RegisterUserDto = RegisterUserDto = tslib_1.__decorate([
    (0, class_validator_jsonschema_1.JSONSchema)({
        description: `Dto for secure method to save public keys for legacy users. Method is called and signed by Curators`
    })
], RegisterUserDto);
/**
 * @description
 *
 * Dto for secure method to save public keys for Eth users.
 * Method is called and signed by Curators
 */
let RegisterEthUserDto = class RegisterEthUserDto extends SubmitCallDTO {
};
exports.RegisterEthUserDto = RegisterEthUserDto;
tslib_1.__decorate([
    (0, class_validator_jsonschema_1.JSONSchema)({ description: "Public secp256k1 key (compact or non-compact, hex or base64)." }),
    (0, class_validator_1.IsNotEmpty)(),
    tslib_1.__metadata("design:type", String)
], RegisterEthUserDto.prototype, "publicKey", void 0);
exports.RegisterEthUserDto = RegisterEthUserDto = tslib_1.__decorate([
    (0, class_validator_jsonschema_1.JSONSchema)({
        description: `Dto for secure method to save public keys for Eth users. Method is called and signed by Curators`
    })
], RegisterEthUserDto);
/**
 * @description
 *
 * Dto for secure method to save public keys for TON users.
 * Method is called and signed by Curators
 */
let RegisterTonUserDto = class RegisterTonUserDto extends SubmitCallDTO {
};
exports.RegisterTonUserDto = RegisterTonUserDto;
tslib_1.__decorate([
    (0, class_validator_jsonschema_1.JSONSchema)({ description: "TON user public key (Ed25519 in base64)." }),
    (0, class_validator_1.IsNotEmpty)(),
    tslib_1.__metadata("design:type", String)
], RegisterTonUserDto.prototype, "publicKey", void 0);
exports.RegisterTonUserDto = RegisterTonUserDto = tslib_1.__decorate([
    (0, class_validator_jsonschema_1.JSONSchema)({
        description: `Dto for secure method to save public keys for TON users. Method is called and signed by Curators`
    })
], RegisterTonUserDto);
class UpdatePublicKeyDto extends SubmitCallDTO {
}
exports.UpdatePublicKeyDto = UpdatePublicKeyDto;
tslib_1.__decorate([
    (0, class_validator_jsonschema_1.JSONSchema)({
        description: "For users with ETH signing scheme it is public secp256k1 key (compact or non-compact, hex or base64). " +
            "For users with TON signing scheme it is public Ed25519 key (base64)."
    }),
    (0, class_validator_1.IsNotEmpty)(),
    tslib_1.__metadata("design:type", String)
], UpdatePublicKeyDto.prototype, "publicKey", void 0);
class UpdateUserRolesDto extends SubmitCallDTO {
}
exports.UpdateUserRolesDto = UpdateUserRolesDto;
tslib_1.__decorate([
    (0, validators_1.IsUserAlias)(),
    tslib_1.__metadata("design:type", String)
], UpdateUserRolesDto.prototype, "user", void 0);
tslib_1.__decorate([
    (0, class_validator_jsonschema_1.JSONSchema)({ description: "New set of roles for the user that will replace the old ones." }),
    (0, class_validator_1.IsNotEmpty)(),
    tslib_1.__metadata("design:type", Array)
], UpdateUserRolesDto.prototype, "roles", void 0);
class GetPublicKeyDto extends ChainCallDTO {
}
exports.GetPublicKeyDto = GetPublicKeyDto;
tslib_1.__decorate([
    (0, class_validator_jsonschema_1.JSONSchema)({
        description: `Id of a public key holder. Optional field, by default caller's public key is returned.`
    }),
    (0, class_validator_1.IsOptional)(),
    (0, validators_1.IsUserRef)(),
    tslib_1.__metadata("design:type", String)
], GetPublicKeyDto.prototype, "user", void 0);
class GetMyProfileDto extends ChainCallDTO {
}
exports.GetMyProfileDto = GetMyProfileDto;
tslib_1.__decorate([
    (0, class_validator_1.IsNotEmpty)(),
    tslib_1.__metadata("design:type", String)
], GetMyProfileDto.prototype, "signature", void 0);
//# sourceMappingURL=dtos.js.map